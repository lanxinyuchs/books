# Utility functions used by various jenkins scripts, intended to be sourced

# FIXME: Update 'merge.sh' to use this file

# Global variables
comp_host=gerritmirror-ha.rnd.ki.sw.ericsson.se
comp_host_push=gerrit.ericsson.se
comp_port=29418
comp_top=rbs_platform/rcs
recipe_findpattern="-name *.bb -o -name *.inc -o -name *.bbappend"

##################################################
# Map recipe directory to component repo
recipe2repo() {
  case $1 in
    */a4ci/*|*/a4ci)             echo rcs-a4ci;;
    */bootfs/*|*/bootfs)         echo rcs-bootfs;;
    */bscan/*|*/bscan)           echo rcs-bscan;;
    */cim/*|*/cim)               echo rcs-cim;;
    */hwtest/*|*/hwtest)         echo rcs-hwtest;;
    */rhai/*|*/rhai)             echo rcs-rhai;;
    */rte/*|*/rte)               echo rcs-rte;;
    */testbox/*|*/testbox)       echo rcs-testbox;;
    */testbox-if/*|*/testbox-if) echo rcs-testbox-if;;
    */linux/*|*/linux)           echo rcs-linux-arm;;
    *)                           echo;;
  esac
}

##################################################
# Map repo to src uri
repo2uri() {

  case $1 in
    rcs-a4ci)       echo ssh://$comp_host:$comp_port/$comp_top/rcs-a4ci;;
    rcs-bootfs)     echo ssh://$comp_host:$comp_port/$comp_top/rcs-bootfs;;
    rcs-bscan)      echo ssh://$comp_host:$comp_port/$comp_top/rcs-bscan;;
    rcs-cim)        echo ssh://$comp_host:$comp_port/$comp_top/rcs-cim;;
    rcs-hwtest)     echo ssh://$comp_host:$comp_port/$comp_top/rcs-hwtest;;
    rcs-rhai)       echo ssh://$comp_host:$comp_port/$comp_top/rcs-rhai;;
    rcs-rte)        echo ssh://$comp_host:$comp_port/$comp_top/rcs-rte;;
    rcs-testbox)    echo ssh://$comp_host:$comp_port/$comp_top/rcs-testbox;;
    rcs-testbox-if) echo ssh://$comp_host:$comp_port/$comp_top/rcs-testbox-if;;
    rcs-linux-arm)  echo ssh://$comp_host:$comp_port/$comp_top/rcs-linux-arm;;
    *)              echo;;
  esac
}

##################################################
# Usage: 'getpv_minor [file]'. Extract minor part of PV from a recipe file or stdin.
# 2nd pattern-action part (not counting BEGIN) is for rcs-linux-arm.
getpv_minor() {
    awk -F\" 'BEGIN {pv=""; err=1;} /^PV *=/ \
          {if (match($2, /[0-9]+\+git/)) \
            {if (length(pv) == 0) {err = 0; pv=sprintf("%s", substr($2, RSTART, RLENGTH-4));}}} \
              /^PVRCS *=/ \
          {if (match($2, /rcs[0-9]+$/)) \
            {if (length(pv) == 0) {err = 0; pv=sprintf("%s", substr($2, RSTART+3, RLENGTH-3));}}} \
          END {if (err == 0) {printf("%s\n", pv);}}' $1
}

##################################################
# Usage: 'getpv_major [file]'. Extract mmajor part of PV from a recipe file ot stdin.
# 2nd pattern-action part (not counting BEGIN) is for rcs-linux-arm.
getpv_major() {
    awk -F\" 'BEGIN {pv=""; pvx=""; err=1;} /^PV *=/ \
          {if (match($2, /[0-9]\./)) \
            {if (length(pv) == 0) {err = 0; pv=sprintf("%s", substr($2, RSTART, RLENGTH-1));}}} \
              /^LINUX_VERSION *=/ \
            {if (length(pv) == 0) {err = 0; pv=sprintf("%s", $2);}} \
              /^LINUX_VERSION_EXTENSION *=/ \
            {if (length(pvx) == 0) {err = 0; pvx=sprintf("%s", $2);}} \
          END {if (err == 0) {printf("%s%s\n", pv, pvx);}}' $1
}

##################################################
# Usage: 'setpv_minor value [file]'. Set minor part of PV in 'file' or stdin.
# 2nd part is for rcs-linux-arm
setpv_minor() {
  sed -i -e 's/^\(PV *= *".*\.\)[0-9]\{1,\}+git/\1'$1+git/ \
    -e 's/^\(PVRCS *= *"rcs\)[^"]\{1,\}"$/\1'$1\"/ $2
}

##################################################
# Get info on a given patch, returns a string like this:
#   comp_branch=master;comp_ref=refs/changes/09/262109/1;comp_open=true;status=NEW;parent=<sha>
# Assign it to a variable and eval that variable to set comp_branch etc
# Usage: some_var=`get_patch_info sha [uri:port]`; eval $some_var
# 'uri:port' (optional)should be in the form returned by 'repo2uri', defaults to
#   gerrit.ericsson.se:29418
get_patch_info() {
  local uri
  local port

  # Extract the relevant part of SRC_URI and if gerrit-mirror, convert
  # to non-mirror (mirror doesn't understand 'gerrit query')
  if [ -n "$2" ]; then
    uri=`echo $2 | sed -e 's%\(ssh://\)\{0,1\}\(.*\):[^.]\{1,\}%\2%' \
                         -e 's/mirror-ha.rnd\.ki\.sw//'`
    port=`echo $2 | sed 's/.*:\([0-9]\{1,\}\).*/\1/'`
  else
    uri="gerrit.ericsson.se"
    port=29418
  fi

  ssh -p $port $uri gerrit query --format TEXT --patch-sets $1 | \
    awk -F: -v sha=$1 'BEGIN {parentline=0;} /^ +branch: / {gsub(" ", "", $2); \
               printf("comp_branch=%s;", $2);} \
             /^ +open: / {gsub(" ", "", $2); printf("comp_open=%s;", $2);} \
             /^ +status: / {gsub(" ", "", $2); printf("comp_status=%s;", $2);} \
             /^ +revision: / {gsub(" ", "", $2); revision = $2;} \
             /^ +ref: / {if (match(revision, sha)) {gsub(" ", "", $2); \
               printf("comp_ref=%s", $2);}} \
             {if (parentline == 1 && (match(revision, sha))) \
               {gsub(/\[|\]| /, "", $0); printf("parent=%s;", $0); parentline=0;}} \
             /^ +parents:/ {if (match(revision, sha)) {parentline=1;}} \
             END {print;}'
}

##################################################
# Find out which components a commit modifies
# Usage: changed_components
#        Current dir must be rcs-yocto top. NB! Only deals with rcs-components.
# Output: list of changed repos. Return code is non-zero in case of
#         errors.
changed_components() {
  local start_dir
  local changed_repos
  local space
  local i
  local recipe_dirs

  recipe_dirs=" \
   layers/meta-rcs/recipes-rcs-platform/a4ci \
   layers/meta-rcs/recipes-rcs-platform/bootfs \
   layers/meta-rcs/recipes-rcs-platform/bscan \
   layers/meta-rcs/recipes-rcs-platform/cim \
   layers/meta-rcs/recipes-rcs-platform/hwtest \
   layers/meta-rcs/recipes-rcs-platform/rhai \
   layers/meta-rcs/recipes-rcs-platform/rte \
   layers/meta-rcs/recipes-rcs-platform/testbox \
   layers/meta-rcs/recipes-rcs-platform/testbox-if \
   layers/meta-bsp-rcs/recipes-kernel/linux"
  space=""

  for i in $recipe_dirs; do
    repo=`recipe2repo $i`
    if [ -z "$repo" ]; then
      continue
    fi
    recipes=`find $i \( $recipe_findpattern \)`
    # Pick up lines like
    #  SRCREV_cpm1 = "37a0941968df797d227fc69620571cc0fe1f40bc"
    #  SRCREV = "37a0941968df797d227fc69620571cc0fe1f40bc"
    # srcrev (and src_prev) becomes 'SRCREV_cpm1=37a0941968df797d227fc69620571cc0fe1f40bc' etc
    srcrev=`git --no-pager diff HEAD~1 $recipes | \
     sed -n '/^+SRCREV/s/^\+SRCREV\(_[^ =]\{1,\}\)\{0,1\} *= *"\([0-9a-f]\{40,40\}\)".*/SRCREV\1=\2/p' | \
     sort`
    srcrev_prev=`git --no-pager diff HEAD~1 $recipes | \
     sed -n '/^-SRCREV/s/^\-SRCREV\(_[^ =]\{1,\}\)\{0,1\} *= *"\([0-9a-f]\{40,40\}\)".*/SRCREV\1=\2/p' | \
     sort`
    if [ -n "$srcrev" ]; then
      if [ -n "$srcrev_prev" ]; then
	# Catch differences between SRCREVs in current and previous commit
	if [ "$srcrev" != "$srcrev_prev" ]; then
	  # Old and new SRCREV differ
	  changed_repos="$changed_repos$space$repo"
          space=" "
        else
          # Old and new SRCREV identical
          continue
	fi
      else
	echo "ERROR: Couldn't find SRCREV in HEAD~1 of $repo" > /dev/stderr
	return 3
      fi
    fi
  done
  [ -n "$changed_repos" ] && echo "$changed_repos"
  return 0
}

##################################################

# Get SRCREV for a particular repo from its recipe (only works for
# rcs-* repos). One line is printed for each found SRCREV, like this:
#
# Usage: get_srcrev <repo>
#        <repo>: rep name, e. g. 'rcs-rhai', 'rcs-hwtest'. Current dir must be rcs-yocto top.
get_srcrev() {
  local recipe
  local srcrev

  recipe=`find_srcrev_file $1`
  if [ -z "$recipe" ]; then
    echo "ERROR: Couldn't find recipe containing SRCREV for $1" > /dev/srderr
    return 2
  fi
  # Pick up lines like
  #  SRCREV_cpm1 = "37a0941968df797d227fc69620571cc0fe1f40bc"
  #  SRCREV = "37a0941968df797d227fc69620571cc0fe1f40bc"
  # srcrev (and src_prev) becomes 'SRCREV_cpm1=37a0941968df797d227fc69620571cc0fe1f40bc' etc
  sed -n '/^SRCREV/s/^SRCREV\(_[^ =]\{1,\}\)\{0,1\} *= *"\([0-9a-f]\{40,40\}\)".*/SRCREV\1=\2/p' $recipe | sort
  return 0
}

##################################################
# Set SRCREV in a repo recipe file
# Usage: set_srcrev value <repo>
#        'value' should have the form 'SRCREV_cpm1=0123...9abcdef'
#           to show *which* SRCREV entry to update
#        'repo' should be like 'rcs-rhai', 'rcs-linux-arm' etc
# Returns non-zero upon error
set_srcrev() {
  local recipe
  local srcrev_val
  local srcrev_name

  srcrev_name=`echo $1 | sed 's/=.*//'`
  srcrev_val=`echo $1 | sed 's/.*=//'`
  if ! recipe=`find_srcrev_file $2`; then
    return 1
  fi
  if ! echo $1 | egrep -q '^SRCREV(_[^ =]+)?=[0-9a-f]+$'; then
    return 2
  fi
  if [ ! `printf $srcrev_val | wc -c` -eq 40 ]; then
    return 3
  fi
  if ! sed -i /^$srcrev_name' *=/s/"[0-9a-f]\{40,40\}"/"'$srcrev_val'"/' $recipe; then
    return 4
  else
    return 0
  fi
}

##################################################
# Find which file contains SRCREV and PV for a certain repo
# Usage: find_srcrev_file <repo>
#        <repo> is the repo name. Current dir must be yocto-top. Only
#        works for rcs repos
# Output: path to the recipe containing SRCREV and PV. Upon error,
#         retuns an empty string and a non-zero return code
find_srcrev_file() {
  local rcs_recipes
  local reciped
  local ret
  local r

  rcs_recipes="layers/meta-rcs/recipes-rcs-platform \
               layers/meta-bsp-rcs/recipes-kernel"

  reciped=""
  # Convert repo name to corresponding recipe dir name
  r=`echo $1 | sed -e 's/^rcs-//' -e 's/-arm$//'`
  for i in $rcs_recipes; do
    if [ -d $i/$r ]; then
      reciped=$i/$r
      break
    fi
  done
  if [ -z "$reciped" ]; then
    # Didn't find any dir containing recipes for this repo
    return 2
  fi

  recipes=`find $reciped \( $recipe_findpattern \)`
  # Find a recipe that contains both SRCREV and PV. Caveat: we're
  # assumin they are always in the same file!
  ret=`awk -F\" '/^SRCREV(_[^ =]+)? *=/ {if ($2 ~ /[0-9a-f]+/) {srcrevf=FILENAME;}} \
                            /^PV *=/ {pvf=FILENAME;} \
                             END {if (srcrevf==pvf) {printf("%s\n", srcrevf);}}' $recipes`
  if [ -z "$ret" ]; then
    return 1
  else
    echo $ret
    return 0
  fi
}

# usage: is_rebase_available change-ID parent-sha [uri:port]
# 'uri:port' (optional)should be in the form returned by 'repo2uri', defaults to
#   gerrit.ericsson.se:29418
# output: sha of already made rebase, empty if not found
#
# The purpose of this function is to find out if the rebase we're
# about to make is already available in gerrit.
is_rebase_available() {
  local uri
  local port

  # Extract the relevant part of SRC_URI and if gerrit-mirror, convert
  # to non-mirror (mirror doesn't understand 'gerrit query')
  if [ -n "$3" ]; then
    uri=`echo $3 | sed -e 's%\(ssh://\)\{0,1\}\(.*\):[^.]\{1,\}%\2%' \
                         -e 's/mirror-ha.rnd\.ki\.sw//'`
    port=`echo $3 | sed 's/.*:\([0-9]\{1,\}\).*/\1/'`
  else
    uri="gerrit.ericsson.se"
    port=29418
  fi

  # In the output from the gerrit query, we look for lines like this:
  #  patchSets:
  #    number: 4
  #    revision: 39c9fc4fa1d0be8d9d5f00cd24acc370c1fab692
  #    parents:
  # [872627aa29bd2159decf88a00decf9462e52ea96]
  #
  # If 'parent' is the one we look for, print its revision
  ssh -p $port $uri gerrit query --format TEXT --patch-sets $1 | \
    awk -F: -v parent=$2 '\
     BEGIN {parentline=0;}
     /^ +revision:/ {rev=$2;} \
     {if (parentline == 1) {parentline=0; \
       if (match($0, parent)) {gsub(/ /, "", rev); printf("%s\n", rev); exit;}}} \
     /^ +parents:/ {parentline=1;}'  
}
  
