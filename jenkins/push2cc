#!/bin/sh

#==================================================
#
# push2cc
#
# Usage: push2cc [-n] [-c commit-log-file]
#        -n - dry run
#        -c - get release info text from file (intended for manual run
#             of push2cc)
#
# Import rcs-ee output into ClearCase. This script is tailor-made for
# use by jenkins. All deliverables need to be placed in current
# directory. All tar.gz files will be unpacked in the very beginning,
# then everything in the current directory will be imported to
# /vobs/rcs/dev/RCP_CSX10179/OS_CRX901265/RCSEE.  Special care is
# taken not to clobber wr5 content in CXA directories.
#
#==================================================

# TODO: Import CAXs?
# TODO: Fix AD?

RDE_TOP=${RDE_TOP:-/vobs/rcs/tools/RDE_LXA119945}
rcsee=/vobs/rcs/dev/RCP_CSX10179/OS_CRX901265/RCSEE
rcsee_cnx=$rcsee/RCSEE_CNX9013327
ct=cleartool
scriptdir=`dirname $0`
scriptdir_abs=`readlink -f $scriptdir`
cxa114_mk=$RDE_TOP/build/CXA114.mk
nextrev=${RDE_TOP}/bin/nextRev
docHandler=${RDE_TOP}/bin/docHandler.sh
dry_run=0
logtextfile=""

# Process options
while getopts nc: opt; do
  case $opt in
    n) dry_run=1;;
    c) logtextfile=$OPTARG;;
    *) echo "Usage: push2cc [-n] [-c commit-log-file]"; exit 2;;
  esac
done
shift `expr $OPTIND - 1`

if [ $dry_run -ne 0 ]; then
  echo=echo
  dry_run1=-preview
  dry_run2=-n
  dry_run3=--dry-run
  echo "Dry run, nothing will be changed in ClearCase"
  echo
fi

if [ ! -d $rcsee ]; then
  echo "ERROR: $rcsee not reachable"
  exit 1
fi

if [ -n "$logtextfile" ]; then
  if [ ! -r $logtextfile ]; then
    echo "Error, not readable: $logtextfile"
    exit 2
  fi
  echo "Will get release info text from $logtextfile"
fi

# TBOX-SUITES should be delivered to /vobs/rcs/test - not handled yet
skip="TBOX-SUITES_CXA1106478.tar.gz"
# Don't deliver TESTBOX-IF although it's a CXA114 (mistake?), it's rcs internal!
skip="$skip TESTBOX-IF_CXA11465.tar.gz"

# Skip CXAs that hasn't changed since last delivery (compare githash
# in artifact with githash in ClearCase)
for i in *CXA*.tar.gz; do
  # No 'githash' in RCSEE (and should always be modified)
  echo $i | grep -q RCSEE && continue
  # Get name of top level dir in tar.gz
  d=`basename $i .tar.gz`
  tar -Ozxf $i $d/githash | cmp -s - $rcsee/$d/githash-wr6
  if [ $? -eq 0 ]; then
    echo "Skipping $i - githash not changed since last delivery"
    skip="$skip $d.tar.gz"
  fi
done

# Unpack tar.gz files (jenkins artifacts)
targz=`ls *.tar.gz 2> /dev/null`
if [ -z "$targz" ]; then
  echo "ERROR: No tar.gz artifacts in current dir (`pwd`)"
  exit 1
fi
for i in $targz; do
  echo $skip | grep -q $i && continue
  echo "Unpacking $i"
  tar zxf $i
  prod_list="$prod_list `basename $i .tar.gz`"
done
cxa_list=`echo $prod_list | tr " " "\n"| grep CXA`
cxa114_list="`echo $prod_list | tr " " "\n"| grep CXA114`"

# Delete anything that is not a word document in doc/15519 in the
# release to be imported. GASK scripts can only handle word docs :-(
for i in $cxa_list; do
  [ -d $i/doc/15519 ] || continue
  for j in `find $i/doc/15519 -maxdepth 1 -mindepth 1`; do
    echo $j | grep -q '\.doc$' && continue
    echo "Moving $j to $i/doc-nonword"
    mkdir -p $i/doc-nonword
    mv $j $i/doc-nonword/15519
  done
done

# IWDs are found in the CXAs of each repo, but should also be
# published under RSCEE_CNX in clearcase, so copy
mkdir -p `basename $rcsee_cnx`/doc/15519
iwd_path=""
# Only modified IWDs are present, so first copy back already
# existing ones, otherwise unmodified IWDs will be wiped away
if [ -d $rcsee_cnx/doc/15519 ]; then
  mkdir -p `basename $rcsee_cnx`/doc/15519
  find $rcsee_cnx/doc/15519 -maxdepth 1 -name \*.doc -exec \
    cp {} `basename $rcsee_cnx`/doc/15519 \;
fi
echo *CXA114*/doc/15519/*.doc | grep -q '\*' || \
 iwd_path='*CXA114*/doc/15519/*.doc'
for i in $iwd_path; do
  echo "Copying $i to RCSEE CNX"
  cp -f $i `basename $rcsee_cnx`/doc/15519
done

#  Rename CXA src top directories/files to '...-wr6' (not the doc dir though)
echo "Renaming to '...-wr6'"
for i in $cxa_list; do
  # Don't rename RCSEE_CXAs, they don't exist under WR5
  echo $i | grep -q RCSEE_CXA && continue
  for j in $i/*; do
    echo $j | egrep -q -- '-wr6$|/doc$' && continue
    if [ -h $j/include ]; then
      rm $j/include
      ln -s ../include-wr6 $j/include
    fi
    if [ -h $j ]; then t=`readlink $j`; rm $j; ln -s $t-wr6 $j; fi
    mv $j $j-wr6
  done
done

# Fix files that has changed from soft links to versions and vice versa
# (clearfsimport can't deal with that)
echo "Looking for soft links that were previously versions in ClearCase"
for i in `find $prod_list -type l -print`; do
  f=$rcsee/$i
  d=`dirname $f`
  [ -r $f ] || continue
  $ct desc -fmt '%m\n' $f | grep -q "version" || continue
  echo "Removing $f to make way for symlink"
  $echo $ct co $d
  $echo $ct rmname $f
  $echo $ct ci -c "Preparing for clearfsimport" $d
done
echo "Looking for soft links in ClearCase that are now changed to versions"
for i in `find $rcsee/*/*-wr6 -type l -print`; do
  d=`dirname $i`
  f=`echo  $i | sed "s:$rcsee/::"`
  [ -f $f ] || continue
  [ -h $f ] && continue
  echo "Removing symlink $i: is now a version"
  $echo $ct co $d
  $echo $ct rmname $i
  $echo $ct ci -c "Preparing for clearfsimport" $d
done

# Copy back wr5 CXA from ClearCase to prevent deleting during import later
echo "Copy back WR5 CXAs before clearfsimport to avoid pruning"
for i in $cxa_list; do
  if [ -d $rcsee/$i ]; then
    echo "  $i"
    # A side effect of the rsync is that we save doc/19010 and
    # doc/17782 from being removed, because their new content haven't
    # been generated yet. Without this, they would be re-created as
    # new elements, which is bad ('evil twins', hides old
    # versions). Note that 'doc' is common to both wr5 and 6.
    rsync -auq --exclude='*-wr6' --exclude=.cmake\* --exclude=15519 $rcsee/$i/ $i
  else
    echo "Not in ClearCase: $i"
  fi
done

# Copy back '.latestlocked' - would be deleted by clearfsimport
[ -f $rcsee_cnx/.latestlocked ] && \
  cp $rcsee_cnx/.latestlocked `basename $rcsee_cnx`

# Actual clearfsimport
tstamp=`date +%Y-%m-%dT%H:%M:%S`
echo "Importing from `pwd` to $rcsee"
unset RDE_CHECK_COPYRIGHT
export NO_CHECKIN_TRIGGER=yes
# Only exclude tar.gz
for i in *; do \
  echo $i | grep -q '\.tar\.gz$' && continue
  set -x
  clearfsimport $dry_run1 -nsetevent -recurse -rmname $i $rcsee || :
  set +x
done

# Make sure nothing is checked out because then, 'setlabels' refuses
# to run (although this can only be a result of some sort of problem)
pushd $rcsee > /dev/null
for i in `$ct lsco -a -s -cview`; do
  echo "Warning: $i was left checked out"
  $echo $ct unco -rm $i
done
popd > /dev/null

# Run 'docHandler.sh' on imported docs to get adm stuff correct
echo "Run docHandler on updated docs (if any)"
for i in `$ct find $rcsee_cnx/doc -version created_since\($tstamp\) -nxname -print`; do
  echo "Running $docHandler on $i"
  $docHandler $i
done

# Container creation and extra labling for CXA114 structures. We need
# to work through *all* CXA114, not just the ones that have changed
# (CM requirement).
for tar in *CXA*.tar.gz; do
  i=`basename $tar .tar.gz`
  cxa_dir=$rcsee/$i
  if [ -d "$cxa_dir" ]; then
    echo "Creating $i/doc/19010/$i.cxa"
    pushd $cxa_dir > /dev/null
    mkdir -p out
    set -x
      # Build the container
    clearmake -f $cxa114_mk CHECK_OUTDIR= CHECK_TGTDIR= out/$i.cxa
    mkdir -p out/doc/19010
    mv out/$i.cxa out/doc/19010
    clearfsimport -nsetevent -recurse $dry_run1 out/doc .
    set +x
    rm -rf out *.xml 2> /dev/null
    echo "Doing CXA114 labling in $i"
    $echo setlabels.sh -ry
    popd > /dev/null
  else
    echo "Skipping $i, not found in $rcsee"
  fi
done

# CNX Labling
# We might have prepared a logtext file in advance (option '-c')
if [ -z "$logtextfile" ]; then
  logtextfile="logtext"
  # Get relase info from commit entries since last *locked* label. If
  # previous label is unlocked (import job crashed?), it means it
  # never triggered an LSV build so those commits were never seen in
  # the CS CI release info.
  lastcnxlabel=`cat $rcsee_cnx/.latestlocked`
  if [ -z "$lastcnxlabel" ]; then
    # In case we didn't find a label ...
    lastcnxlabel="`git rev-parse HEAD~1`"
  else
    # In case the label hasn't been pushed back to git ...
    git tag | grep -q $lastcnxlabel || lastcnxlabel="`git rev-parse HEAD~1`"
  fi
  echo "User: $name ($USER)\nPurpose:" > $logtextfile
  echo "Getting commit log from $lastcnxlabel to now"
  echo "Listing commits since $lastcnxlabel" >> $logtextfile
  if [ -n "$BUILD_NUMBER" ]; then
    echo "Jenkins delivery job number: $BUILD_NUMBER" >> $logtextfile
  fi
  git --no-pager log --name-status HEAD...$lastcnxlabel | \
    perl -wpe '$cnt+=length; if ($cnt>20000) {print " - Truncated"; last;}' \
    >> $logtextfile
fi

# Extract solved TRs from the commit log (goes into the CC attr 'SolvedTR')
SolvedTR=`perl -ne 'if (($tr=$_)=~s/^\s*TR:\s*([A-Z][A-Z][0-9][0-9][0-9][0-9][0-9]).*/$1/) \
            {print "$tr" unless /:REMOVED/;}' $logtextfile | sort -u | tr "\n" " "`
if [ -n "$SolvedTR" ]; then
  echo "Found solved TR(s): $SolvedTR"
else
  echo "No solved TRs"
fi

PurposeText=`sed 's/$/\\\\n/' $logtextfile | tr -d "\012\042\047\140"`

echo "Attaching release labels"
pushd $rcsee > /dev/null
$echo setlabels.sh -y
newcnxlabel=`$nextrev -ld $rcsee_cnx`

# Set label attribute values
DeliveryDestination=""
DeliveryType="Ordinary delivery"
DependencyText=""
FileList=""
FileOrderText=""
InstallationText=""

error=0
[ $dry_run -eq 0 ] && set -x
$echo $ct mkattr -rep DeliveryDestination \""$DeliveryDestination"\" lbtype:$newcnxlabel || error=1
$echo $ct mkattr -rep DeliveryType \""$DeliveryType"\" lbtype:$newcnxlabel || error=1
$echo $ct mkattr -rep DependencyText \""$DependencyText"\" lbtype:$newcnxlabel || error=1
$echo $ct mkattr -rep FileList \""$FileList"\" lbtype:$newcnxlabel || error=1
$echo $ct mkattr -rep FileOrderText \""$FileOrderText"\" lbtype:$newcnxlabel || error=1
$echo $ct mkattr -rep InstallationText \""$InstallationText"\" lbtype:$newcnxlabel || error=1
$echo $ct mkattr -rep PurposeText \""$PurposeText"\" lbtype:$newcnxlabel || error=1
$echo $ct mkattr -rep SolvedTR \""$SolvedTR"\" lbtype:$newcnxlabel || error=1
set +x
[ $error -ne 0 ] && echo "Error: some 'ct mkattr' cmd failed"
popd > /dev/null

# Tag the git commit with the new CNX label
$echo git checkout `cat rcs-ee.version`
echo "Pushing back clearcase label $newcnxlabel to git"
cd ..; git submodule status | git tag --file - $newcnxlabel
set -x
git push $dry_run3 origin refs/tags/$newcnxlabel || :
set +x

# Lock CXA114 labels
pushd $rcsee > /dev/null
for i in *CXA114*; do
  cd $i
  echo "Locking labels in $i"
  $echo setlabels.sh -yL
  cd ..
done

# Lock the CNX label. This triggers a CS CI LSV build.
# The following variables are needed for the PRIM functions run by
# 'setlabels' to work
export RACF_USER=rcsci1
export SSO_USER=rcsci1
export PRIVATE_D=$HOME/private

echo "Locking CNX label in `pwd`"
$echo setlabels.sh -yL
ret=$?
[ $dry_run -ne 0 ] && echo "DRY_RUN was set, nothing updated in ClearCase"

# Save the new CNX label if locked, We need this next time as a
# starting point for creating the release summary ('$logtext').
if [ `$ct desc -fmt '%[locked]p\n' lbtype:$newcnxlabel` = locked ]; then
  echo "Saving the new label ($newcnxlabel) in $rcsee_cnx/.latestlocked"
  $echo $ct co -nc $rcsee_cnx/.latestlocked
  echo $newcnxlabel > $rcsee_cnx/.latestlocked
  $echo $ct ci -nc $rcsee_cnx/.latestlocked
fi

exit $ret
