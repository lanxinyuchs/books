#!/usr/bin/expect
#
# Run 'signclient login' to prepare for secure boot signing. Uses ssl
# private rsa key to decrypt credentials used for logging in.
#
# Some openssl commands:
#  1. Convert public rsa key to pem:
#    openssl rsa -in ~/.ssh/id_rsa -out ~/.ssh/id_rsa.pub.pem -outform PEM -pubout
#  2. Convert private rsa key to pem:
#    openssl rsa -in ~/.ssh/id_rsa -out ~/.ssh/id_rsa.pem -outform PEM
#  3. Encrypt file:
#    openssl rsautl -encrypt -pubin -inkey ~/.ssh/id_rsa.pub.pem \
#      -in credentials -out ~/.secure_EE/`hostname`/signclient.credentials.rsa
#  4. Decrypt:
#    openssl rsautl -decrypt -inkey private.pem -in encrypted -out plain2
#
# Do 1-3 manually once. This program does 4 plus logging in. The file
# "credentials" in 3 above should look like this (except the dashes
# and pipes):
#
# --------------------------------------------------
# |# signclient credentials for esekilvxen515
# |TrustStore password: secret
# |KeyStore password: very_secret
# |Ericsson signer username: rcsci2
# |Ericsson signer password: incredibly_secret
# --------------------------------------------------
#
# Note that the left hand side text matches the prompts given by
# "signclient login". The idea is that the prompts from the signclient
# program form associative array keys that will find the value to send
# at each prompt. Thus, if ever the prompts change (assuming a new
# version of 'signclient' is introduced), this program shouldn't need
# modification, only the credentials file.
#
# Björn Wirén 2015-04-01
#--------------------------------------------------

puts "Doing signclient login"

set host [exec hostname]
if {$env(USER) == "rcsci2"} {
    set confdir $env(HOME)/.secure_EE/$host
    set opt_c "-c $confdir/signclient.properties"
} else {
    set confdir $env(HOME)/.secure_EE
    set opt_c ""
}
set credfile $confdir/signclient.credentials.rsa
set rsa $env(HOME)/.ssh/id_rsa.pem

if {[catch {glob $rsa}]} {
    puts "Error: can't find $rsa"
    exit 1
}
if {[catch {glob $credfile}]} {
    puts "Error: can't find $credfile"
    exit 1
}

# Read and decrypt the credentials file
set creds [exec openssl rsautl -decrypt -inkey $rsa -in $credfile]
set creds "$creds\n"
set strlen [string length $creds]
set ch1 0
set loop 0
while {$ch1 < $strlen} {
    # Find end of current line
    set ch2 [expr $ch1 + [string first "\n" [string range $creds $ch1 end]]]
    # Skip ending \n
    incr ch2 -1
    set line [string range $creds $ch1 $ch2]
    # Parse line: left of ':' is 'key' (but replace spaces with '_',
    # to the right is 'value'
    if {[regexp {^ *#} $line] == 0} {
	regsub {^([^:]+):.*} "$line" {\1} key1
	regsub -all { } $key1 _ key
	regsub {^[^:]+: } "$line" "" value
	set cr($key) $value
    }
    # Advance to start of next line
    set ch1 $ch2
    incr ch1 2
    if {$loop > 4} {
	puts "Error: more than 4 lines in decrypted $credfile"
	exit 1
    }
    incr loop
}

# Dump keys found in the credentials file (helps if something goes
# wrong)
puts "Extracted from $credfile (SPC conv to '_'):"
foreach i [array names cr] {
    puts "  $i"
}

# Now for some expect
log_user 0
spawn /bin/bash
# exp_internal 1
# Set our own prompt
send "PS1='%> '\r"
expect -re "\r\n(%> )$" {
    set prompt $expect_out(1,string)
}
send "module use /app/rbs/cs/modules\r"
expect "$prompt"
send "module add signclient\r"
expect "$prompt"
send "signclient $opt_c login\r"
while 1 {
    expect {
	-re "\r\n(.*): $" {
	    regsub -all { } $expect_out(1,string) _ query
	    if {[info exists cr($query)]} {
		puts "Sending $query"
		send "$cr($query)\r"
	    } else {
		puts "Unexpected prompt from signclient: $query"
		exit 1
	    }
	}
	-re "\r\n(.+)\r\n$prompt$" {
	    puts "Unexpected response from signclient:"
	    puts "$expect_out(1,string)"
	    exit 1
	}
	-re "^\r\n$prompt$" {
	    break
	}

    }
}
puts "Login completed"
