/*
 *
 * Copyright (c) Ericsson AB 2015 All rights reserved.
 *
 * The information in this document is the property of Ericsson. Except
 * as specifically authorized in writing by Ericsson,the receiver of this
 * document shall keep the information contained herein confidential
 * and shall protect the same in whole or in part from disclosure and
 * dissemination to third parties. Disclosure and disseminations to the
 * receiver's employees shall only be made on a strict need to know basis.
 */

/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf 11805 2005-01-07 09:37:18Z dts12 $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "ericssonDiscoveryMIB.h"
#include <string.h>

#define EriDiscoveryStateValue_disabled  0
#define EriDiscoveryStateValue_enabled   1

static long origStatus = 0;

/** Get discovery status from file */
void
get_discovery_status(long *status) {
  char* rcsRoot;
  char filename[200];
  FILE *fd;

  /* Not allowed to modify return from getenv (rcsRoot points to actual env variable) */
  rcsRoot = getenv("RCS_ROOT");

  if (rcsRoot == NULL) {
    DEBUGMSGTL(("ericssonDiscoveryMIB", "get: env RCS_ROOT is missing, assuming target\n"));
    strcpy(filename, "/rcs/networkloader/discoveryStatus");
  }
  else {
    /* filename = $RCS_ROOT/rcs/networkloader/discoveryStatus */
    strcpy(filename, rcsRoot);
    strcat(filename, "/rcs/networkloader/discoveryStatus");  
  }

  DEBUGMSGTL(("ericssonDiscoveryMIB", "get: filename %s\n", filename));
  fd = fopen(filename, "r");
  if (fd == NULL) {
    DEBUGMSGTL(("ericssonDiscoveryMIB", "get: no file created\n"));
    *status = EriDiscoveryStateValue_enabled;
  }
  else {
    fscanf(fd, "%ld", status);
    DEBUGMSGTL(("ericssonDiscoveryMIB", "get: discovery value returned %ld\n", *status));
    fclose(fd);
  }
}

/** Set discovery status in file */
void
set_discovery_status(long newStatus) {
  char* rcsRoot;
  char filename[200];
  long currentStatus;
  FILE *fd;

  get_discovery_status(&currentStatus);
  
  /* From eriDiscoveryStatus (ERICSSON-DISCOVERY-MIB):
   * "If a manager sets this value to enabled(1) the node may
   *  choose to resume sending of discovery messages - or it
   *  may deny such a request by immediately reseting this value
   *  to disabled(0)."
   * RBS denies going from disabled(0) to enabled(1).
   */

  if (newStatus == currentStatus || currentStatus == EriDiscoveryStateValue_disabled) {
    DEBUGMSGTL(("ericssonDiscoveryMIB", "set: status NOT updated\n"));
  }
  else {
    DEBUGMSGTL(("ericssonDiscoveryMIB", "set: status updated new %ld current %ld\n", 
		newStatus, currentStatus));
    
    /* Not allowed to modify return from getenv (rcsRoot points to actual env variable) */ 
    rcsRoot = getenv("RCS_ROOT");
    
    if (rcsRoot == NULL) {
      DEBUGMSGTL(("ericssonDiscoveryMIB", "set: env RCS_ROOT is missing\n"));
      strcpy(filename, "/rcs/networkloader/discoveryStatus");
    }
    else {
      /* filename = $RCS_ROOT/rcs/networkloader/discoveryStatus */
      strcpy(filename, rcsRoot);
      strcat(filename, "/rcs/networkloader/discoveryStatus");
    }

    DEBUGMSGTL(("ericssonDiscoveryMIB", "set: filename %s\n", filename));
    fd = fopen(filename, "w");
    fprintf(fd, "%ld", newStatus);
    fclose(fd);
  }
}

/** Initializes the ericssonDiscoveryMIB module */
void
init_ericssonDiscoveryMIB(void)
{
  static oid      eriDiscoveryStatus_oid[] =
    { 1, 3, 6, 1, 4, 1, 193, 183, 5, 1, 1 };
  
  DEBUGMSGTL(("ericssonDiscoveryMIB", "Initializing\n"));

  netsnmp_register_scalar(netsnmp_create_handler_registration
			  ("eriDiscoveryStatus",
			   handle_eriDiscoveryStatus,
			   eriDiscoveryStatus_oid,
			   OID_LENGTH(eriDiscoveryStatus_oid),
			   HANDLER_CAN_RWRITE));
}

int
handle_eriDiscoveryStatus(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
  int  ret;
  long discoveryStatus;
  
  /*
   * We are never called for a GETNEXT if it's registered as a
   * "instance", as it's "magically" handled for us.  
   */

  /*
   * a instance handler also only hands us one request at a time, so
   * we don't need to loop over a list of requests; we'll only get one. 
   */

  switch (reqinfo->mode) {

  case MODE_GET:
    DEBUGMSGTL(("ericssonDiscoveryMIB", "MODE_GET \n"));
    get_discovery_status(&discoveryStatus);
    snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER, discoveryStatus);
    break;

    /*
     * SET REQUEST
     *
     * multiple states in the transaction.  See:
     * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
     */
  case MODE_SET_RESERVE1:
    DEBUGMSGTL(("ericssonDiscoveryMIB", "MODE_SET_RESERVE1 \n"));
    ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
    if (ret != SNMP_ERR_NOERROR) {
      DEBUGMSGTL(("ericssonDiscoveryMIB", "MODE_SET_RESERVE1 wrong type\n"));
      netsnmp_set_request_error(reqinfo, requests, ret);
      return (ret);
    }
    
    /* Can only take value 0 (disabled) or 1 (enabled) */
    if(*(requests->requestvb->val.integer) > EriDiscoveryStateValue_enabled || 
       *(requests->requestvb->val.integer) < EriDiscoveryStateValue_disabled) {
      DEBUGMSGTL(("ericssonDiscoveryMIB", "MODE_SET_RESERVE1 badvalue\n"));
      netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
      return(SNMP_ERR_BADVALUE);
    }

    /* Save original discoveryStatus in case of MODE_SET_UNDO */
    get_discovery_status(&discoveryStatus);
    origStatus = discoveryStatus;
    break;
    
  case MODE_SET_RESERVE2:
    DEBUGMSGTL(("ericssonDiscoveryMIB", "MODE_SET_RESERVE2 \n"));
    break;

  case MODE_SET_FREE:
    DEBUGMSGTL(("ericssonDiscoveryMIB", "MODE_SET_FREE \n"));
    break;

  case MODE_SET_ACTION:
    DEBUGMSGTL(("ericssonDiscoveryMIB", "MODE_SET_ACTION \n"));
    DEBUGMSGTL(("ericssonDiscoveryMIB", "requests->requestvb->val: [%ld]\n", *(requests->requestvb->val.integer)));
    break;

  case MODE_SET_COMMIT:
    DEBUGMSGTL(("ericssonDiscoveryMIB", "MODE_SET_COMMIT \n"));
    DEBUGMSGTL(("ericssonDiscoveryMIB", "requests->requestvb->val: [%ld]\n", *(requests->requestvb->val.integer)));
    set_discovery_status(*(requests->requestvb->val.integer));
    break;

  case MODE_SET_UNDO:
    DEBUGMSGTL(("ericssonDiscoveryMIB", "MODE_SET_UNDO \n"));
    set_discovery_status(origStatus);
    break;

  default:
    /*
     * we should never get here, so this is a really bad error
     */
    snmp_log(LOG_ERR,
	     "unknown mode (%d) in handle_eriDiscoveryStatus\n",
	     reqinfo->mode);
    return SNMP_ERR_GENERR;
  }
    
  return SNMP_ERR_NOERROR;
}
