#!/bin/bash
## %CCaseFile:	nodetool %
## %CCaseRev:	/main/R2A/R3A/R4A/R5A/R6A/R8A/R9A/1 %
## %CCaseDate:	2017-01-24 %
## Author: erarafo
##
## Purpose: Carry out various node-related tasks.
##
## Dependencies: Several scripts in the RCT environment:
##
##   $RCT_TOP/test/lib/shell/common.sh
##   erlang_log_viewer
##   reserve_node.sh
##   rcs_install.sh
##   upgradeprep.sh
##   rct_run.sh
##   rcs_upview.sh
##   swm_SUITE.erl
##   rcs_cpuload_monitor.sh
##   toerl
##   app_info.escript
##   rcs_telnet.pl
##   rcs_power.pl
##   rcs_logview.sh
##   rcs_exec
##
## TODO: Support for node UPs
## TODO: set the title in xterms consistently (except for Moshell)
## TODO: Pick up SW version using NETCONF
## TODO: "Activate" should undo PublicKeyInstalled?
## TODO: Undo memory of installed software when upgrade
## TODO: memory of last session, per nodename, clearable with -c?
##
## %CCaseCopyrightBegin%
## Copyright (c) Ericsson AB 2014-2017 All rights reserved.
##
## The information in this document is the property of Ericsson.
##
## Except as specifically authorized in writing by Ericsson, the
## receiver of this document shall keep the information contained
## herein confidential and shall protect the same in whole or in
## part from disclosure and dissemination to third parties.
##
## Disclosure and disseminations to the receivers employees shall
## only be made on a strict need to know basis.
## %CCaseCopyrightEnd%
## ----------------------------------------------------------------------
##
## Revision history:
##
## Rev        Date       Name        What
## -----      -------    --------    ------------------------------------
## R2A/1      2014-01-16 erarafo     First version
## R2A/2      2014-01-17 erarafo     Added "view Erlang log filtered"
## R2A/3      2014-01-17 erarafo     Bugfix
## R2A/5      2014-03-02 erarafo     More board types added
## R2A/6      2014-04-07 erarafo     Load monitor added
## R2A/7      2014-04-07 erarafo     Adjustments
## R2A/8      2014-04-24 erarafo     Support for 'Moshell'
## R2A/9      2014-04-24 erarafo     Buggy version
## R2A/10     2014-04-24 erarafo     Support for 'Moshell' adjusted
## R2A/11     2014-04-29 erarafo     Added a 'fetch' operation
## R2A/12     2014-05-07 erarafo     Added 'follow Erlang log'
## R2A/13     2014-05-07 erarafo     Buggy version
## R2A/14     2014-05-07 erarafo     Buggy version
## R2A/15     2014-05-08 erarafo     Support for simulator
## R2A/16     2014-05-08 erarafo     Added 'about'
## R2A/17     2014-05-09 erarafo     Verbose mode elaborated
## R2A/18     2014-05-16 erarafo     Improved way of specifying UPs
## R2A/19     2014-05-20 erarafo     Source labels
## R2A/20     2014-05-23 erarafo     Adjustments
## R2A/21     2014-05-26 erarafo     Added Telnet session
## R2A/22     2014-05-28 erarafo     NODETOOL_EXPERT hidden feature
## R2A/23     2014-05-28 erarafo     Upgrade 'x' option, bugfix
## R2A/24     2014-05-30 erarafo     Added power control feature
## R2A/25     2014-06-04 erarafo     Extra options in rcssim
## R2A/26     2014-06-30 erarafo     Support for tcu03 UPs
## R2A/27     2014-07-04 erarafo     Support for tcu03 WR6 UPs
## R2A/28     2014-07-04 erarafo     Nothing
## R2A/29     2014-07-04 erarafo     Workaround for read-only ~root/
## R2A/30     2014-08-07 erarafo     Removed support for dotted-IP
## R2A/31     2014-08-18 erarafo     Root password provided for some actions
## R2A/33     2014-08-18 erarafo     Support for new EE structure
## R2A/34     2014-08-18 erarafo     Root password provided for SSH session
## R2A/35     2014-08-26 erarafo     Adapted for the branched environment
## R2A/36     2014-10-05 erarafo     Try to cure "Stale NFS file handle"
## R3A/1      2014-10-20 erarafo     Adjusted Moshell invocation
## R3A/2      2014-10-24 erarafo     Handle dus3201 installs too
## R3A/3      2014-10-28 erarafo     Ensure /local/scratch/SIGNUM/RCS_ROOT
## R3A/4      2014-11-06 erarafo     Follow Erlang log, minor fix
## R3A/5      2014-11-12 erarafo     Install lab license
## R3A/6      2014-11-22 erarafo     Line length in SSH session increased
## R3A/7      2014-12-01 erarafo     Selectable password mode
## R3A/8      2014-12-09 erarafo     Log summary; experimental, sim only
## R3A/9      2014-12-15 erarafo     Log summary; experimental, sim only
## R3A/10     2015-01-26 erarafo     SFTP access added
## R3A/11     2015-02-20 erarafo     Sticky CXS spec for initial install
## R3A/12     2015-03-09 erarafo     Help extended
## R3A/13     2015-03-22 erarafo     Sticky extra options for SIM install
## R3A/14     2015-03-25 erarafo     Menu entry: kill simulator
## R3A/15     2015-04-14 erarafo     Workaround for netconf port issue
## R3A/16     2015-04-17 erarafo     TCU04 support
## R4A/1      2015-06-05 erarafo     Report booking status with less clutter
## R4A/2      2015-06-17 erarafo     Adapted to lab SFTP server change
## R4A/3      2015-06-17 erarafo     CXS prefix for tcu0401 corrected
## R4A/4      2015-10-05 erarafo     More scrollable xterm windows
## R4A/5      2015-10-29 erarafo     Limited support for external nodes; public key handling removed
## R5A/1      2015-12-14 erarafo     APPLOG support
## R5A/2      2016-01-20 erarafo     APPLOG, window size; suggesting previous patch file as default
## R5A/3      2016-03-23 erarafo     Remembering last responses with 'fetch'
## R5A/4      2016-04-11 erarafo     Verbose-enabled upview
## R6A/1      2016-06-28 erarafo     Removed "structure" question, -s option still available
## R6A/2      2016-06-30 erarafo     Fixed launch of Erlang shell on VRCS
## R6A/3      2016-07-01 erarafo     Further VRCS support
## R6A/4      2016-07-01 erarafo     'vrcs' as argument, -t option dropped
## R6A/5      2016-08-16 erarafo     Added Unix PID to 'about' printout
## R6A/7      2016-08-19 erarafo     Tuned VRCS support
## R6A/8      2016-08-23 erarafo     Tuned VRCS support further
## R6A/10     2016-08-26 erarafo     Development branch queried lazily
## R6A/11     2016-08-26 erarafo     Finding common.sh via relative path
## R8A/3      2017-01-05 erarafo     Adapted to changes in product ids
## R8A/4      2017-01-18 erarafo     CPU load in VRCS
## R8A/5      2017-01-18 erarafo     Minor adjustment
## R9A/1      2017-01-24 erarafo     Adjusted help text
declare -r ScriptVersion=`echo '%CCaseRev:	/main/R2A/R3A/R4A/R5A/R6A/R8A/R9A/1 %' | sed -e 's|..$||' -e 's|, checkout.*|-checkedout|' -e 's|^.*/\([^/]*/[^/]*\)$|\1|'`

declare -r ScriptDir=`dirname $0`
source $ScriptDir/../lib/shell/common.sh

declare -r StructureDefault=new
declare -r RootPassword='root'
declare -r PasswordModeDefault=auto


function about() {
  local xOptions="-geometry 65x60 -sb -bg $greyish"
  export ABOUT_TEXT="Nodetool is a launchpad for sessions towards a running CS node,
the simulator, or a vRCS instance.

Version: $ScriptVersion
The process id of this instance is: $$

Suggestions etc are welcome to rabbe.fogelholm@ericsson.com

R6A/7     Tuned support for VRCS
R6A/5     Including own PID in 'about' printout
R6A/4     Fairly complete support for VRCS
R6A/2     Partial support for VRCS
R6A/1     Removed "structure" question, -s option still available
R5A/3     Remembering last responses with 'fetch'
R5A/2     Elaborated help on UP selection
R5A/1     Support for following and viewing APPLOG (the ift_app log)
R4A/5     Limited support for external nodes; public key handling removed
R4A/4     Scrollable xterm windows in more situations
R4A/1     Report booking status with less clutter
R3A/16    TCU04 support
R3A/15    Showing correct value for NETCONF port
R3A/14    Menu entry "shutdown" for simulator
R3A/13    Old extra options is default in "install" action
R3A/12    More help with Erlang shell
R3A/11    Old CXS is default in "install" action
R3A/10    SFTP session
R3A/9     Thematic log summary, experimental
R3A/7     Selectable password mode for SSH session
R3A/6     Increased line length in SSH session
R3A/5     Added: Installation of license
R3A/3     Minor fix
R3A/2     Minor fix
R3A/1     Fixed: Moshell invocation
R2A/35    Adaptations for the branched environment
R2A/34    Some password prompts eliminated
R2A/31    Fixed: Source labels on TCU03 nodes
R2A/29    Workaround: Key installation when read-only ~root/
R2A/28    Fixed: Erlang shell launch
R2A/26    Updated: Board and UP types
R2A/25    Added: Passing options to 'rcssim'
R2A/24    Added: Power cycling support
R2A/21    Added: Telnet support
R2A/19    Added: Launch of simulator (simplistic)
R2A/19    Added: Listing of source labels
R2A/18    Improved: Upgrade support
R2A/17    Improved: Verbose mode
R2A/16    Added: Feature history
R2A/15    Added: Simulator support ('nodetool sim')
R2A/12    Added: Follow Erlang log
R2A/10    Added: Moshell support
R2A/6     Added: CPU load monitor

"
  xterm $xOptions -T "nodetool $ScriptVersion" \
    -e bash -c 'echo "$ABOUT_TEXT"; cat /dev/tty' &
}


declare -r Script=nodetool
declare -r LabConfig=/proj/webdocs/rbs-rde-wiki/root/data/Main/LabConfig.txt
declare -r Moshell=/app/moshell/latest/moshell/moshell
declare -r MoshellVarsSim='comcli=22,username=expert,password=expert'
declare -r MoshellVarsTarget='comcli=21,username=expert,password=expert'

declare -r DuUser=sirpa

declare -r SimAreaDefault=/local/scratch

# Colors chosen with gpick on ELX
declare -r blueish='#D6EEFF'
declare -r yellowish='#FDFFE0'
declare -r greenish='#E0FFE6'
declare -r greyish='#F4F4F4'
declare -r peachish='#FFE9D1'
declare -r pinkish='#FFF0FE'
declare -r eggshell='#F0EAD6'

declare -r Scrollable="-sb -sl 40000"



function help() {
  cat <<EOF
nodetool version: $ScriptVersion

Usage is: $Script [OPTIONS] [sim|dus0123|tcu4567|vrcs|rcf_${USER}]

Options are:
  -h             this help
  -a DOTTED_IP   specify external node by dotted-IP address
  -i DIRECTORY   simulator installation directory, defaults to: $SimAreaDefault/$USER
  -s STRUCTURE   EE structure, one of old or new, defaults to: $StructureDefault
  -v             verbose

The -i option can be used if the simulator is installed in a non-default place,
i e something other than $SimAreaDefault/$USER.

When specifying the node as 'vrcs' the -a option is required.
EOF
}


function die() {
  printf "$Script: FATAL: $1\n" >&2
  exit 1
}


function info() {
  printf "$Script: INFO: $1\n" >&2
}


function warning() {
  printf "$Script: WARNING: $1\n" >&2
}


function say() {
  printf "%s\n" "$1"
}


# slowSay MESSAGE
#
# Delay slightly, allowing a trace message to break in
# before this message

function slowSay() {
  local message="$1"; shift
  sleep 1
  say "$message"
}



# getString PROMPT [DEFAULT]
#
# Gets a string typed by the user.

function getString() {
  local -r prompt="$1"; shift
  local begin=$((`date +%s` - `cat $IdleSeconds`))
  if [[ $# -eq 0 ]]; then
    printf "%s: " "$prompt" >&2
    read result
    echo $((`date +%s` - begin)) >$IdleSeconds
    echo "$result"
  else
    local -r default="$1"; shift
    printf "%s [%s]: " "$prompt" "$default" >&2
    read result
    echo $((`date +%s` - begin)) >$IdleSeconds
    if [[ -z "$result" ]]; then
      echo "$default"
    else
      echo "$result"
    fi
  fi
}



# isSpaceFree STRING
#
# Returns true if the string has no embedded whitespace.

function isSpaceFree() {
  local string="$1"; shift
  [[ "_$string" == "`echo _$string | tr -d ' \t'`" ]]
}



# isNumeral STRING
#
# Returns true if the string is a non-empty pure numeral.

function isNumeral() {
  local string="$1"; shift

  [[ -n "$string" ]] && [[ "`echo $string | tr -d 0123456789`" == "" ]]
}


# bookedBy NODE
#
# Returns an empty string if the node is not booked, or the
# username of the booker.
# TODO: Check for script failure before deciding.

function bookedBy() {
  reserve_node.sh -a $Node \
  | sed \
      -e "/^$Node/!d" \
      -e 's|^[^\t]*\t[^\t]*\t[^\t]*\t[^\t]*\t[^\t]*\t[^\t]*\t[^\t]*\t||' \
      -e 's|[\s\t].*||'
}



# getUpHelp RSTATE_DEFAULT
#
#

function getUpHelp() {
  local -r rstateDefault="$1"; shift
  cat <<EOF >&2
Specify an upgrade package as follows:
  567                 CI web, short for ${CxsPrefix}-${rstateDefault}567
  ${rstateDefault}789              CI web, short for ${CxsPrefix}-${rstateDefault}789
  http://...          URL to download from
  https://...         URL to download from
  some/file           CXS file in tar.gz format

When specifying just a number (like 567 above) the R-state is derived from
the config spec of the current view.
EOF
}


# getUp PROMPT PREFIX [DEFAULT]
#
# Asks for a UP specification. Useful prefixes are provided
# for some reply patterns. Examples (assuming 'sim'):
#
#     4444                 -> CXS101549_2-R2B4444
#     R2B4444              -> CXS101549_2-R2B4444
#     CXS101549_2-R2B4444  -> CXS101549_2-R2B4444
#     http://...           -> http://...
#     https://...          -> https://...
#     OTHER                -> `readlink -f OTHER`


function getUp() {
  local prompt="$1"; shift
  local prefix="$1"; shift
  local default
  local -r rcsRstateDefault="`devBranch`"

  if [[ $# -eq 0 ]]; then
    default=""
  else
    default="$1"; shift
  fi

  getUpHelp "$rcsRstateDefault"
  local reply=`getString "$prompt" $default`
  if isNumeral "$reply"; then
    # pure numeral
    echo ${prefix}-${rcsRstateDefault}$reply
  elif echo "$reply" | grep --silent '^R[1-9][0-9]*[A-Za-z]'; then
    echo ${prefix}-$reply
  else
    case "$reply" in
      CXS101549*)
        echo $reply;;
      [Hh][Tt][Tt][Pp]://*)
        echo $reply;;
      [Hh][Tt][Tt][Pp][Ss]://*)
        echo $reply;;
      *)
        if [[ -r "$reply" ]]; then
          readlink -f "$reply"
        else
          echo NO_UP_DEFINED
        fi
    esac
  fi
}



function upgradeHelp() {
  cat <<EOF >&2
Basic upgrade to a higher CXS version, available in the
middleware CI web, is supported.

Specify a sequence of tasks, using letters c p v a k:

  c: create the UpgradePackage MO
  p: execute the 'prepare' step
  v: execute the 'verify' step
  a: execute the 'activate' step
  k: confirm the upgrade

  x: skip upload of UP to SFTP server

An UpgradePackage MO can be manually removed using the CLI
(the full DN must be given).

The 'x' option saves some time if an upgrade is to be re-run
and the UP is already in place on the SFTP server.
EOF
}


function getUpgradeTasks() {
  local reply=`getString 'upgrade tasks' 'cpvak'`
  local result=""
  case "$reply" in *[cC]*) result+=" create"; esac
  case "$reply" in *[pP]*) result+=" prepare"; esac
  case "$reply" in *[vV]*) result+=" verify"; esac
  case "$reply" in *[aA]*) result+=" activate"; esac
  case "$reply" in *[kK]*) result+=" confirm"; esac
  case "$reply" in *[xX]*) result+=" skipUpload"; esac
  if [[ -z "$result" ]]; then
    echo noTestcaseSpecified
  else
    echo $result
  fi
}


# isPosInt NUMERAL
#
# Returns true if the given string is a positive integer.
# Leading zeros are not tolerated.

function isPosInt() {
  local -r word="$1"; shift
  case "$word" in
    0*)
      false;;
    *)
      [[ "$word" != "0" && -z "`echo $word | tr -d '0123456789'`" ]]
  esac
}



# selectWord INDEX W1 W2 ...
#
# Selects the word indicated by the given index. It is trusted
# that the index is not out of range. Indexing starts at 1.

function selectWord() {
  local -r k="$1"; shift
  local j=$((0))
  for w in $*; do
    j=$((j+1))
    if [[ $((k)) -eq $((j)) ]]; then
      echo $w
      break
    fi
  done
}



# multiSelect PROMPT E1 E2 ...
#
# Gets a selection of the given words.

function multiSelect() {
  local prompt="$1"; shift
  local number=$((0))
  local words=""
  for e in $*; do
    number=$((number+1))
    entry="`echo $1 | sed -e 's|.*=||' -e 's|%| |g'`"
    word="`echo $1 | sed -e 's|=.*||'`"
    printf "%4d: %s\n" $number "$entry" >&2
    words+=" $word"
    shift
  done
  printf "\n" >&2
  local isDone=false
  local result
  while [[ $isDone != true ]]; do
    result=""
    kk=`getString "$prompt" | tr ',' ' '`
    isDone=true
    for k in $kk; do
      if ! isPosInt $k; then
        say "ill-formed number: $k" >&2
        isDone=false
        break
      elif [[ $((k)) -gt $((number)) ]]; then
        say "selection out of range: $k" >&2
        isDone=false
        break
      fi
      x=`selectWord $k $words`
      result+=" $x"
    done
  done
  echo $result
}

# menuSelect PROMPT E1 E2 ...
#
# Gets one word selected from the given words.

function menuSelect() {
  local prompt="$1"; shift
  local selection=`multiSelect $prompt $*`
  if [[ `echo $selection | wc --words` -gt 1 ]]; then
    say "Multiple selection not supported." >&2
    menuSelect "$prompt" $*
  else
    echo "$selection"
  fi
}

# getStructure
#
# Gets the word 'old' or 'new'. Previous reply is remembered
# and provided as default. The initial remembered value can be set with
# the -s option.

# function getStructure() {
#   local structure=`getString 'EE structure' $StructurePrevious`
#   case "$structure" in
#     old|new)
#       StructurePrevious=$structure
#       echo $structure;;
#     *)
#       cat <<EOF >&2
# Please specify 'new' or 'old'.
#
# In the new structure EE and Middleware are bundled together
# as a CXP of CXPs, whereas in the old structure they are
# separate CXPs.
# EOF
#     getStructure
#   esac
# }
function getStructure() {
  echo $Structure
}


# getCxsPrefix DU_TYPE

function getCxsPrefix() {
  local -r duType="$1"; shift
  case "$duType" in

    # Simulator
    sim)
      echo CXS101549_2;;

    # PowerPC boards (duw1101 may no longer exist)
    dus4101|duw4101|duw1101)
      echo CXS101549_1;;

    # TCU03 boards
    tcu03)
      local structure=`getStructure`
      case $structure in
        old)
          echo CXS101549_3;;
        new)
          # echo CXS101549_6  .. even newer is _9
          echo CXS101549_9
      esac;;

    # TCU04 boards
    tcu0401)
      # echo CXS101549_6  .. even newer is _9
      echo CXS101549_9;;

    # DUS32 and DUS52 boards
    dus[35]201)
      local structure=`getStructure`
      case $structure in
        old)
          echo CXS101549_3;;
        new)
          # echo CXS101549_5 .. even newer is _8
          echo CXS101549_8
      esac;;

    *)
      echo unknown
  esac
}


# getMonitorWindowHeight DU_TYPE

function getMonitorWindowHeight() {
  local -r duType="$1"; shift
  local nCpus
  case "$duType" in
    dus4101|duw4101|duw1101)
      nCpus=4
      echo $((nCpus*2 + 3));;
    tcu03)
      nCpus=8
      echo $((nCpus*2 + 3));;
    tcu0401)
      nCpus=12
      echo $((nCpus*2 + 3));;
    dus5201)
      nCpus=12
      echo $((nCpus*2 + 3));;
    *)
      nCpus=12
      echo $((nCpus*2 + 3))
  esac
}



function pageHeader() {
  local nodeType
  local address
  if [[ $Node == external ]]; then
    nodeType=unknown
  elif [[ `getDuType "$Node"` == vrcs ]]; then
    nodeType=vrcs
  else
    nodeType="`getDuType $Node`"
  fi

  if [[ -n "$Address" ]]; then
    address=$Address
  else
    address=''
  fi

  if [[ $Node == sim ]]; then
    printf "Node: %s" $Node
  elif [[ `getDuType "$Node"` == vrcs ]]; then
    printf "Node: %s, address: %s" $Node $address
  else
    printf "Node: %s, type: %s, address: %s" $Node $nodeType $address
  fi
  if [[ $CxsVersion == none ]]; then
    printf "\n"
  else
    printf ", installed: %s\n" $CxsVersion
  fi
  if [[ $Verbose == true ]]; then
    printf "%s\n" "Verbose"
  fi
  printf "%s\n\n" "-------------------------------------------"
}


function splash() {
  xterm \
    -bg green \
    -geometry 50x11 \
    -font '-adobe-courier-bold-r-normal--34-*-*-*-*-*-*-*' \
    -e bash \
      -c 'printf "\n\n\n\n\n   =========== installation ready ===========" && sleep 3'
}


# trace Word...
#
# For Verbose == true, display the words.
#
# DEPRECATED, use 'execute' instead

function trace() {
  local -r command="$*"
  if [[ $Verbose == true ]]; then
    say "$command"
  fi
}


# execute Word...
#
# Execute the given command, with trace optionally.
# It is assumed that the first word (the command)
# is space free.

function execute() {
  local firstWord=true
  if [[ $Verbose == true ]]; then
    for word in "$@"; do
      if [[ $firstWord == true ]]; then
        printf "executing: %s" "$word"
        firstWord=false
      elif ! isSpaceFree "$word"; then
        printf ' "%s"' "$word"
      else
        printf " %s" "$word"
      fi
    done
    printf "\n"
  fi
  "$@"
}


function leash() {

  local now=`date +%s`
  local secondsElapsed=$((now - ActionBegin - `cat $IdleSeconds`))
  local timeElapsed=`printf "%d:%02d" $((secondsElapsed / 60)) $((secondsElapsed % 60))`

  getString "[$timeElapsed] Push Enter to proceed"
  if interrupted; then true; fi
}

function erlangSessionHints() {
  cat <<EOF
Erlang shell session launched. Some useful function calls:

  appmI:restart_node(cold, "").         % restart node

  appmServer:stop_lm("ift_app", 0).     % stop IFT
  appmServer:start_lm("ift_app", 0).    % start IFT
                                        %
  comsaI:stop_com().                    % stop COM
  comsaI:start_com([]).                 % start COM
                                        %
  Ctrl-D                                % terminate this shell
EOF
}


# setXtermTitle STRING

function setXtermTitle() {
  local -r title="$1"; shift
  printf "\033]0;%s\007" "$title"
}


# copyToDirs SOURCE NODE DIR...
#
# The NODE argument is ignored in the simulator environment.
#
# Otherwise use a node name or vrcs@W.X.Y.Z.

function copyToDirs() {
  local -r source="$1"; shift
  local -r node="$1"; shift

  for d in $*; do
    if [[ "$Node" == sim ]]; then
      if execute cp $source ${RcsRoot}$d; then
        say "copied to: ${RcsRoot}$d/`basename $source`"
      else
        warning "copying to directory failed: ${RcsRoot}$d"
      fi
    else
      if ! execute nodeScp $source $node:$d; then
	warning "copying to node directory failed: $node:$d"
      fi
    fi
  done
}



function helpFilter() {
  cat <<EOF
Specify any mix of lowercase letter, or NONE for no
filtering. Valid letters are:

  p    suppress PROGRESS reports
  i    suppress INFO reports
  w    suppress WARNING reports
  e    suppress ERROR reports
  c    suppress CRASH reports
  s    suppress SUPERVISOR reports

EOF
}



# viewFile ABS_SOURCE_PATH [convert|filter]
#
# Uses Address from global scope. The given source path starts
# with a '/'; on target it is an absolute path but for the
# simulator a prefix is needed.

function viewFile() {
  local sourcePath="$1"; shift
  local arg1
  if [[ $# -eq 0 ]]; then
    arg1=none
  else
    arg1=$1; shift
  fi

  if [[ $arg1 == filter ]]; then
    helpFilter
    local filterOptionsReply=`getString 'filter options' 'NONE'`

    local filterOptions="-E"
    for x in p i w e c s; do
      case "$filterOptionsReply" in
        *${x}*)
          filterOptions+="$x"
      esac
    done
    if [[ "$Node" == sim ]]; then
      cat ${RcsRoot}$sourcePath | erlang_log_viewer $filterOptions -- -
    else
      ssh $SshOptions $Address cat $sourcePath | erlang_log_viewer $filterOptions -- -
    fi
  else
    local localFile=`mktemp -u --tmpdir=/tmp $USER-XXXXXXXX`

    if [[ "$Node" == sim ]]; then
      if ! cp ${RcsRoot}$sourcePath $localFile; then
	warning: failed to copy file: $RcsRoot/$sourcePath
      else
	if [[ $arg1 == convert ]]; then
	  dos2unix $localFile
	fi
	chmod -w $localFile
	(${EDITOR:-emacs} $localFile && rm -f $localFile)&
      fi
    else
      if ! nodeScp "$ScpRemote:$sourcePath" $localFile; then
	warning "failed to read remote file: $sourcePath"
      else
	if [[ $arg1 == convert ]]; then
	  dos2unix $localFile
	fi
	chmod -w $localFile
	(${EDITOR:-emacs} $localFile && rm -f $localFile)&
      fi
    fi
  fi
}


# getPort PORTID
#
# Simulator only.

function getPort() {
  local portId=$1; shift

  local portConfigFiles=`find -L $RcsRoot/home/$USER/releases -name port.conf`
  local ports=`cat $portConfigFiles | sed -e "/{${portId},/!d" -e 's|.*,||' -e 's|}.*||'`
  if [[ `echo $ports | fmt -w 1 | sort -u | wc --lines` -ne 1 ]]; then
    echo undefined
  else
    echo $ports | fmt -w 1 | head -n 1
  fi
}


# sourceLabels

function sourceLabels() {
  if [[ "$Node" == sim && $RcsRoot == $SimAreaDefault/$USER/RCS_ROOT ]]; then
    local appFiles=`find -L $SimAreaDefault/$USER/RCS_ROOT/home/$USER/software/*CXP9021221* -name '*.app' | tr '\n' ' '`
    xterm -geometry 90x35 -bg $greyish -T 'Source labels' -e bash \
      -c "app_info.escript $appFiles; cat /dev/tty" &
  elif [[ "$Node" == sim ]]; then
    warning "not available when simulator is installed to non-default path"
  else
    local scriptFile=`mktemp -u --tmpdir=/tmp $USER-XXXXXXXX`
    cat <<'EOF' | sed -e "s|NODE_TMP_DIR|$NodeTmpDir|" >$scriptFile
#! /bin/bash
if [[ -d `echo /software/VRCS-MW_CXP9029176_4_*/OTP2_CXC1733859_2/otp-*/priv/tgt_i686_32` ]]; then
  export OTP_ROOT=`echo /software/VRCS-MW_CXP9029176_4_*/OTP2_CXC1733859_2/otp-*/priv/tgt_i686_32`
  export PATH=NODE_TMP_DIR:$OTP_ROOT/bin:$PATH
  app_info.escript `find -L /home/sirpa/software/*CXP* -name '*.app'`
elif [[ -d `echo /software/VRCS-MW_CXP9029176_2_*/OTP2_CXC1733859_2/otp-*/priv/tgt_i686_32` ]]; then
  export OTP_ROOT=`echo /software/VRCS-MW_CXP9029176_2_*/OTP2_CXC1733859_2/otp-*/priv/tgt_i686_32`
  export PATH=NODE_TMP_DIR:$OTP_ROOT/bin:$PATH
  app_info.escript `find -L /home/sirpa/software/*CXP* -name '*.app'`
elif [[ -d `echo /software/RCSMW-ARM_CXP9025546_3_*/OTP3_CXC1733859_3/otp-*/priv/tgt_arm-wr6` ]]; then
  export OTP_ROOT=`echo /software/RCSMW-ARM_CXP9025546_3_*/OTP3_CXC1733859_3/otp-*/priv/tgt_arm-wr6`
  export PATH=NODE_TMP_DIR:$OTP_ROOT/bin:$PATH
  app_info.escript `find -L /home/sirpa/software/*CXP9025546_3* -name '*.app'`
else
  export OTP_ROOT=`echo /software/*CXP9021221*/OTP*_CXC*/otp-*/priv/*`
  export PATH=NODE_TMP_DIR:$OTP_ROOT/bin:$PATH
  app_info.escript `find -L /home/sirpa/software/*CXP9021221* -name '*.app'`
fi
EOF
    chmod +x $scriptFile
    nodeScp $scriptFile $ScpRemote:$NodeTmpDir/app_info_wrapper
    rm $scriptFile
    nodeScp `type -p app_info.escript` $ScpRemote:$NodeTmpDir
    xterm -geometry 90x65 -bg $greyish -T 'Source labels' -e bash \
      -c "ssh $SshOptions $Address $NodeTmpDir/app_info_wrapper; cat /dev/tty" &
  fi
}


function power() {
  if [[ "$Node" == "sim" ]]; then
    say "not applicable for simulator"
  elif [[ `getDuType "$Node"` == vrcs ]]; then
    say "not applicable for VRCS (consider COLI help board/restart)"
  elif [[ "$Node" == external ]]; then
    say "not applicable for external node"
  else
    local choice=`getString "Specify one of: read cycle off on" cycle`
    case "$choice" in
      read|cycle|off|on)
        execute /proj/rcs/bin/rcs_power.pl $Node $choice;;
      *)
        warning "not an option: $choice"
    esac
  fi
}


function installLicense() {
  if [[ `getDuType "$Node"` == vrcs ]]; then
    local opts=" -m cli -f - -a $Address"
  else
    local opts=" -m cli -f - $Node"
  fi
  rcs_exec $opts <<EOF
ManagedElement=1,SystemFunctions=1,Lm=1
configure
fingerprint=tn_lab4
commit
KeyFileManagement=1
installKeyFile sftp://dustest@10.68.101.150/proj/rcs-tmp/tn_lab4_141008_082950.xml dustest
exit
EOF
}


function logView() {
  local xOptions="-geometry 120x70 $Scrollable"
  local keywords=undefined
  while [[ "$keywords" == undefined ]]; do
    keywords=`getString 'keywords' help`
    if [[ "$keywords" == help ]]; then
      rcs_logview.sh -h
      keywords=undefined
    elif [[ $Node == sim ]]; then
      xterm $xOptions \
        -e bash \
          -c "rcs_logview.sh -k $keywords $RcsRoot/rcs/erlang/erlang.log.1; sleep 999999"
      break
    else
      say "NYI: only simulator support right now, FIXME"
      break
    fi
  done
}


function getPasswordMode() {
  local done=false
  local pwModeReply
  local pwMode
  while [[ $done != true ]]; do
    pwModeReply=`getString "password mode: auto/prompt/help" $PasswordMode`
    case "$pwModeReply" in
      [Aa]|auto)
        done=true
        pwMode=auto;;
      [Pp]|prompt)
        done=true
        pwMode=prompt;;
      [Hh]|help)
        done=true
        pwMode=help;;
      *)
        say "type one of a, p, h" >&2
    esac
  done
  if [[ $pwMode == help ]]; then
    cat <<EOF >&2
The password mode for SSH sessions can
be one of

  auto    No password needs to be typed,
          but the width of the console
          window cannot be adjusted.

  prompt  The password is prompted for,
          and the width of the console
          window can be adjusted as
          needed.

EOF
    getPasswordMode
  else
    echo $pwMode
  fi
}


function applogHelp() {
  cat <<EOF >&2
The "applog" is written by the IFT application
by calls to the APPLOG, CALL, RCALL and DRCALL
macros. Such calls are made by the master.c and
child.c modules and can also be used in
interface-specific test_*.c modules.

The default log level is INFO. Test cases may
change the log level dynamically; see
test_self.c for an example.

Selecting 'follow' brings up an xterm window
where the log can be observed in real time.
Selecting 'view' causes a snapshot of the log
to be displayed in an editor window.
EOF
}


function applogPathName() {
  if [[ `getDuType "$Node"` == vrcs ]]; then
    echo /rcs/applicationlogs/VRCS-DUMMY_CXP9029207_4/ift_app.log
  else
    case "$DuType" in
      sim)
	echo /rcs/applicationlogs/DUMMY-SIM_CXP9021691_2/ift_app.log;;
      tcu*|dus*)
	echo /rcs/applicationlogs/DUMMY-ARM_CXP9021691_3/ift_app.log
    esac
  fi
}


function doApplog() {
  case `menuSelect "choice" help follow view`+$Node in
    help+*)
      applogHelp
      doApplog;;
    follow+sim)
      execute xterm $Scrollable -bg $greyish -geometry 140x50 -T 'APPLOG' -e tail -f ${RcsRoot}`applogPathName` &
      say "following the APPLOG; Ctrl-C in log window terminates)";;
    follow+*)
      execute xterm $Scrollable -bg $greyish -geometry 140x50 -T 'APPLOG' -e ssh $SshOptions $Address tail -f `applogPathName` &
      say "following the APPLOG; Ctrl-C in log window terminates)";;
    view+*)
      viewFile `applogPathName`
  esac
}




########################################################################
# Execution begins here


declare OptionPatterns=""
declare OptionPatterns+="h"
declare OptionPatterns+="a:"
declare OptionPatterns+="i:"
declare OptionPatterns+="s:"
declare OptionPatterns+="v"
declare Structure=$StructureDefault
declare SimulatorPath=""
declare Verbose=false
declare ExtAddress=""
while getopts $OptionPatterns OPT; do
  case "$OPT" in
    h)
      help; exit;;
    a)
      ExtAddress=$OPTARG;;
    i)
      SimulatorPath="$OPTARG";;
    s)
      Structure="$OPTARG";;
    v)
      Verbose=true;;
    *)
      die "Unknown option, try -h for help"
  esac
done; shift $((OPTIND - 1))


if [[ $# -gt 1 ]]; then
  die "too many arguments, try -h for help"
elif [[ $# -eq 1 ]]; then
  declare -r Node="$1"; shift
  if [[ "$Node" == sim ]]; then
    if [[ -n "$ExtAddress" ]]; then
      die "option -a and 'sim' cannot be combined, try -h for help"
    fi
    declare -r DuType=sim
  elif [[ "$Node" == vrcs ]]; then
    if [[ -z "$ExtAddress" ]]; then
      die "option -a required with 'vrcs', try -h for help"
    else
      declare -r Address="$ExtAddress"
      declare -r DuType=vrcs
      declare -r ScpRemote=vrcs@$ExtAddress
      declare -r NodeTmpDir="/tmp"
    fi
  elif [[ -n "$ExtAddress" ]]; then
    die "option -a and '$Node' cannot be combined, try -h for help"
  else
    case "$Node" in
      rcf*)
        # assume a VRCS node
	  declare -r Address=`getAddress $Node`
	  declare -r ScpRemote=$Node
	  declare -r NodeTmpDir="/tmp";;
      *)
	# assume a dus* or tcu* node
	declare -r DuType="`getDuType $Node`"
	if [[ -z "$DuType" ]]; then
	  die "cannot determine type of node '$Node'"
	else
	  declare -r Address=`getAddress $Node`
	  declare -r ScpRemote=$Node
	  declare -r NodeTmpDir="/dev/shm"
	fi
    esac
  fi
elif [[ -z "$ExtAddress" ]]; then
  die "no -a option and no node specified, try -h for help"
else
  # implied external node
  declare -r Node=external
  declare -r DuType=unknown
  declare -r Address="$ExtAddress"
  declare -r ScpRemote="external@$ExtAddress"
  declare -r NodeTmpDir="/dev/shm"
fi

# At this point Node, DuType, Address and ExtAddres are set, except for the
# 'sim' case where Node == DuType == 'sim'.

# echo "      Node: $Node"
# echo "    DuType: $DuType"
# echo "   Address: $Address"
# echo " ScpRemote: $ScpRemote"
# exit


if [[ "$Node" == sim ]]; then
  if [[ -n "$SimulatorPath" ]]; then
    declare RcsRoot=$SimulatorPath/RCS_ROOT
  else
    declare RcsRoot=$SimAreaDefault/$USER/RCS_ROOT
  fi
  mkdir -p $RcsRoot
  if [[ ! -d $RcsRoot ]]; then
    die "not a directory: $RcsRoot"
  fi
fi

case "$Structure" in
  old|new)
    true;;
  *)
    die "value of -s option must be 'old' or 'new', try -h for help"
esac

# Experimental...
# mkdir -p /dev/shm/$USER
# declare -r HostsFile=/dev/shm/$USER/known-hosts-$$
# cat /dev/null >$HostsFile

# Experimental...
# declare -r SecurityOptions="-o StrictHostKeyChecking=no -o UserKnownHostsFile=$HostsFile"
declare -r SecurityOptions="-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null"

declare -r ScpOptions="-o user=root $SecurityOptions"
declare -r SshOptions="-2 -l root $SecurityOptions"
declare -r SshCliOptions="-2 -t -p 2023 -l expert $SecurityOptions"
declare -r SshColiOptions="-2 -t -p 4192 -l expert $SecurityOptions"
declare -r SftpOptions="-o port=2024 -o user=expert $SecurityOptions"

declare selection
declare KeyInstalled=false
declare CxsVersion=none
declare CxsToVersion=none
declare CxsVersionOld=none
declare PatchFile
declare OldPatchFile=""
declare UpgradePatchFile
declare OldUpgradePatchFile=""
declare OldRemotePath=""
declare Title="$Script $ScriptVersion  $Node $Address"
declare Reply
declare UpgradeTestcases
declare OldUp=""
declare ActionBegin
declare TargetDir
declare TargetDirOld=""
declare RemoteFilePattern
declare RemoteFilePatternOld=""
declare Command

declare UpTasksParsed
declare UpTasks

declare RcsSimOptions
declare RcsSimOptionsOld=none

declare PasswordMode=$PasswordModeDefault
declare NetconfPort=undefined


mkdir -p /dev/shm/$USER
declare -r IdleSeconds=/dev/shm/$USER/nodetool-idleseconds-$$
echo $((0)) >$IdleSeconds


if [[ "$CxsVersion" != none ]]; then
  Title+=" $CxsVersion"
fi


declare -r Menu="
	 bookingStatus=booking%status
	initialInstall=initial%install
		  ping=ping
          sourceLabels=source%labels
	       upgrade=upgrade
	showPortConfig=show%port%config
	browseMetadata=browse%metadata
	    sshSession=SSH%session
	    cliSession=CLI%session
	   coliSession=COLI%session
	 erlangSession=Erlang%shell
       followErlangLog=follow%Erlang%log
	 viewErlangLog=view%Erlang%log
 viewErlangLogFiltered=view%Erlang%log%filtered
    viewSwmInternalLog=view%SwmInternal%log
		  view=view%file
                 fetch=fetch%file(s)
		  edit=edit%file
	   insertPatch=insert%patch
    insertUpgradePatch=insert%patch%for%upgrade
               cpuLoad=CPU%load
               moshell=Moshell
	       verbose=verbose
                 about=about
		  exit=exit
         telnetSession=Telnet%session%(new)
                 power=power%cycle%(new)
        installLicense=install%license%(new)
               logView=Erlang%log%summary%(experimental)
           sftpSession=SFTP%session%(new)
              shutdown=shutdown%(new)
                applog=applog%(new)
"


declare InterruptFlag

function interrupted() {
  if [[ $InterruptFlag == false ]]; then
    false
  else
    printf "\nInterrupted.\n"
    InterruptFlag=false
    leash
    true
  fi
}


trap "InterruptFlag=true" INT





while true; do
  InterruptFlag=false
  clear
  setXtermTitle "$Title"
  pageHeader

  selection=`menuSelect select $Menu`
  ActionBegin=`date +%s`
  echo $((0)) >$IdleSeconds
  case "$selection" in

    bookingStatus)
      if [[ "$Node" == sim ]]; then
        say "not applicable for simulator"
      elif [[ $Node == external ]]; then
        say "not applicable for external node"
      elif [[ `getDuType "$Node"` == vrcs ]]; then
        say "not applicable for VRCS node"
      else
        BookedBy=`bookedBy $Node`
	# reserve_node.sh -a $Node
        if [[ -z "$BookedBy" ]]; then
          say "node $Node is not booked"
        else
          say "node $Node is booked by: $BookedBy"
        fi
      fi
      leash;;

    initialInstall)
      if [[ "$Node" == sim ]]; then
	CxsPrefix=`getCxsPrefix $DuType`
        if [[ "$CxsVersionOld" == none ]]; then
          CxsVersion=`getUp 'upgrade package' $CxsPrefix`
        else
          CxsVersion=`getUp 'upgrade package' $CxsPrefix $CxsVersionOld`
        fi
        # TODO, consider wrapping this pattern into a function
        RcsSimOptions=`getString 'extra rcssim options' "$RcsSimOptionsOld"`
        if [[ "$RcsSimOptions" == none ]]; then
          RcsSimOptions=""
        fi
        RcsSimOptionsOld="$RcsSimOptions"

        case "$CxsVersion" in
          CXS*)
            Command="rcssim $RcsSimOptions -c -l $CxsVersion";;
          http*|/*)
            Command="rcssim $RcsSimOptions -c -p $CxsVersion";;
          *)
            die "internal error, CxsVersion: $CxsVersion"
        esac
        # be verbose at all times
        say "launching: $Command"
        xterm $Scrollable -bg $greyish -geometry 70x30 -e $Command &
        CxsVersionOld=$CxsVersion
      elif [[ `getDuType "$Node"` == vrcs ]]; then
        say "not supported for VRCS node"
      elif [[ $Node == external ]]; then
        say "not supported for external node"
      else
	CxsPrefix=`getCxsPrefix $DuType`
	case "$CxsPrefix" in
	  unknown)
	    die "CXS prefix unknown for DU type: $DuType";;
	  *)
            if [[ "$CxsVersionOld" == none ]]; then
	      CxsVersion=`getUp 'upgrade package' $CxsPrefix`
            else
	      CxsVersion=`getUp 'upgrade package' $CxsPrefix $CxsVersionOld`
            fi
	    if interrupted; then continue; fi
	    if [[ $CxsToVersion == NO_UP_DEFINED ]]; then
	      warning "no such UP"
	      continue
	    fi
	    Command="rcs_install.sh $Node $CxsVersion"
            case "${NODETOOL_EXPERT:-false}" in
              true|[Yy]*|1)
                warning "the NODETOOL_EXPERT feature does not work (yet)";;
              *)
                true
            esac
            execute $Command
            # Experimental...
	    # cat /dev/null >$HostsFile
            CxsVersionOld=$CxsVersion
	esac
	splash
	KeyInstalled=false
      fi
      leash;;

    upgrade)
      if [[ `getDuType "$Node"` == vrcs ]]; then
        say "not supported for VRCS node"
      elif [[ $Node == external ]]; then
        say "not supported for external node"
      else
	CxsPrefix=`getCxsPrefix $DuType`
	case "$CxsPrefix" in
	  unknown)
	    die "CXS prefix unknown";;
	  *)
	    upgradeHelp
	    UpTasksParsed="`getUpgradeTasks`"
	    if interrupted; then continue; fi

	    UpTasks=""
	    for t in $UpTasksParsed; do
	      if [[ "$t" != skipUpload ]]; then
		UpTasks+=" $t"
	      fi
	    done

	    case "$UpTasks" in
	      *create*)
		case "$UpTasksParsed" in
		  *skipUpload*)
		    true;;
		  *)
		    CxsToVersion=`getUp 'target UP' $CxsPrefix $OldUp`
		    if interrupted; then continue; fi
		    if [[ $CxsToVersion == NO_UP_DEFINED ]]; then
		      warning "no such UP"
		      continue
		    fi
		    OldUp=$CxsToVersion
		    if [[ "$Node" == sim ]]; then
		      upgradeprep.sh -sim ${USER}_sim $CxsToVersion
		    else
		      upgradeprep.sh -stp $Node $CxsToVersion
		    fi
		esac
	    esac

	    if [[ "$UpTasks" == noTestcaseSpecified ]]; then
	      warning "no testcase specified"
	    else
	      info "upgrade tasks: $UpTasks"
	      if [[ "$Node" == sim ]]; then
		(cd $RCT_TOP/test/suites/SWM && rct_run.sh -sim ${USER}_sim -suite swm_SUITE -case $UpTasks)
	      else
		(cd $RCT_TOP/test/suites/SWM && rct_run.sh -stp $Node -suite swm_SUITE -case $UpTasks)
	      fi
	      case "$UpTasks" in
		*activate*)
		  # Experimental...
		  # cat /dev/null >$HostsFile
		  KeyInstalled=false
	      esac
	    fi
	esac
      fi
      leash;;

    ping)
      if [[ "$Node" == sim ]]; then
        say "not applicable for simulator"
      else
	ping -c 2 -n $Address
      fi
      leash;;

    sshSession)
      if [[ "$Node" == sim ]]; then
        (cd $RcsRoot && xterm $Scrollable -bg $greyish) &
        say "xterm session launched."
      else
	PasswordMode=`getPasswordMode`
	if [[ $PasswordMode == auto ]]; then
	  Command="ssh $SshOptions $Address"
	  trace "$Command"
	  xterm $Scrollable -geometry 140x40 -bg $greyish -e \
	    expect \
	      -c "spawn ssh $SshOptions $Address" \
	      -c 'expect "s password"' \
	      -c 'send "root\r"' \
	      -c 'interact' \
	    &
	else
          Command="ssh $sshOptions -l root $Address"
          trace "$Command"
          xterm $Scrollable -bg $greyish -e $Command &
	fi
	sleep 1
	say "SSH session launched."
      fi
      leash;;

    followErlangLog)

      if [[ $Node == sim && ! -d $RcsRoot/rcs/erlang ]]; then
        say "the Erlang log does not exist (yet)"
        leash
      elif [[ $Node == sim && `find $RcsRoot/rcs/erlang -type f -name 'erlang.log.[123456789]' | wc --lines` -eq 0 ]]; then
        say "the Erlang log does not exist (yet)"
        leash
      else
       	case $Node in
	  sim)
            execute xterm $Scrollable -bg $greyish -geometry 120x50 -T 'Erlang log' -e tail -f `ls -1 $RcsRoot/rcs/erlang/erlang.log.* | tail -n 1` &
	  ;;
	  *)
            execute xterm $Scrollable -bg $greyish -geometry 120x50 -T 'Erlang log' -e ssh $SshOptions $Address tail -f /rcs/erlang/erlang.log.1 &
	esac
	say "following the Erlang log; Ctrl-C in log window terminates)"
	leash
      fi;;

    erlangSession)
      if [[ "$Node" == sim ]]; then
        trace xterm $Scrollable -bg $blueish -T 'RCS Erlang' -e to "&"
        xterm $Scrollable -bg $blueish -T 'RCS Erlang' -e to &
	erlangSessionHints
      else
        toErl=`ssh $SshOptions $Address ls -1 \
                   "/home/$DuUser/software"'/*CXP9021221*/OTP*_CXC1733859_*/otp-*/priv/tgt_i686/bin/to_erl' \
                   "/home/$DuUser/software"'/*CXP9025546_*/OTP*_CXC1733859_*/otp-*/priv/tgt_arm-wr6*/bin/to_erl' \
                   "/home/$DuUser/software"'/*CXP9029176_[24]_*/OTP*/otp-*/priv/tgt_i686_32/bin/to_erl' \
               2>/dev/null \
               | head -n 1`
        case "$toErl" in
          /home/sirpa/software/*CXP9029176_[24]*)
            toErlTmpDir=/tmp/root@vrcs/;;
          *)
            toErlTmpDir=/tmp/$DuUser@du1/
        esac

	trace "located to_erl executable: '$toErl', using temp dir: '$toErlTmpDir'"
        if [[ -z "$toErl" ]]; then
          warning "failed to locate 'to_erl' command; no action"
        else
	  trace xterm $Scrollable -bg $blueish -T "'RCS Erlang'" -e ssh $SshOptions $Address $toErl $toErlTmpDir "&"
	  xterm $Scrollable -bg $blueish -T 'RCS Erlang' -e ssh $SshOptions $Address $toErl $toErlTmpDir &
	  erlangSessionHints
        fi
      fi
      leash;;

    cliSession)
      if [[ "$Node" == sim ]]; then
        trace xterm $Scrollable -bg $yellowish -fg black -T "'COM CLI'" -e rcssim_ssh cli "&"
        xterm $Scrollable -bg $yellowish -fg black -T 'COM CLI' -e rcssim_ssh cli &
      else
	trace xterm $Scrollable -bg $yellowish -T "'COM CLI'" -e ssh $SshCliOptions $Address "&"
	xterm $Scrollable -bg $yellowish -T 'COM CLI' -e ssh $SshCliOptions $Address &
      fi
      say "CLI session launched, password is: expert"
      leash;;

    telnetSession)
      if [[ "$Node" == sim ]]; then
        say "not applicable for simulator"
      elif [[ `getDuType "$Node"` == vrcs ]]; then
        say "not applicable for vrcs"
      elif [[ $Node == external ]]; then
        say "not applicable for external node"
      else
        CommandArgs="$Scrollable -bg $pinkish -e rcs_telnet.pl $Node"
        trace xterm $CommandArgs "&"
        xterm -T "Telnet $Node (Ctrl-5 to interrupt)" $CommandArgs &
	say "Telnet session launched. To interrupt, use Ctrl-5 (on"
	say "a Swedish keyboard) or Ctrl-] (on a US keyboard)."
      fi
      leash;;

    coliSession)
      if [[ "$Node" == sim ]]; then
        trace xterm $Scrollable -bg $greenish -T "'RCS" "COLI'" -e rcssim_ssh coli "&"
        xterm $Scrollable -bg $greenish -T 'RCS COLI' -e rcssim_ssh coli &
      else
	trace xterm $Scrollable -bg $greenish -T "'RCS" "COLI'" -e ssh $SshColiOptions $Address "&"
	xterm $Scrollable -bg $greenish -T 'RCS COLI' -e ssh $SshColiOptions $Address &
	say "COLI session launched, password is: expert"
      fi
      leash;;

    showPortConfig)
      if [[ "$Node" == sim ]]; then
        portConfigFiles=`find -L $RcsRoot/home/$USER/releases -name port.conf`
      elif [[ `getDuType "$Node"` == vrcs ]]; then
        # TODO, what if multiple files here?
        portConfigFiles=`ssh $SshOptions $Address find -L /root/releases -name port.conf | head -n 1`
        NetconfPort=`(echo ManagedElement=1,SystemFunctions=1,SysM=1,OamAccessPoint=1; echo show netconfPort; echo exit) | rcs_exec -m cli -f - -a $Address | sed -e '/^netconfPort=/!d' -e 's|^netconfPort=||' -e 's|[ \t\r]*$||'`
      else
        portConfigFiles=`ssh $SshOptions $Address find -L /home/$DuUser/releases -name port.conf`
        NetconfPort=`(echo ManagedElement=1,SystemFunctions=1,SysM=1,OamAccessPoint=1; echo show netconfPort; echo exit) | rcs_exec -m cli -f - $Node | sed -e '/^netconfPort=/!d' -e 's|^netconfPort=||' -e 's|[ \t\r]*$||'`
      fi
      for f in $portConfigFiles; do
        printf "$f -\n"
        if [[ "$Node" == sim ]]; then
          Ports="`cat $f`"
        else
          Ports="`ssh $SshOptions $Address cat $f`"
        fi
        echo $Ports \
        | fmt -w 1 \
        | (while read x; do
             key=`echo $x | sed -e 's|.*{||' -e 's|,.*||'`
             value=`if [[ $key == netconf && $Node != sim ]]; then echo $NetconfPort; else echo $x | sed -e 's|.*,||' -e 's|}.*||'; fi`
             printf "%16s:%6s\n" "$key" "$value"
           done
          )
        printf "\n"
      done
      leash;;

    browseMetadata)
      if [[ "$Node" == sim && $RcsRoot == $SimAreaDefault/$USER/RCS_ROOT ]]; then
        say "browser launched; do NOT use browser built-in 'back' function"
        execute rcs_upview.sh &
      elif [[ "$Node" == sim ]]; then
        warning "not available when simulator is installed to non-default path"
      elif [[ $Node == external ]]; then
        say "browser launched; do NOT use browser built-in 'back' function"
        execute xterm -e rcs_upview.sh -d $Address &
      elif [[ `getDuType "$Node"` == vrcs ]]; then
        say "browser launched; do NOT use browser built-in 'back' function"
        execute xterm -e rcs_upview.sh -d $Address &
      else
        say "browser launched; do NOT use browser built-in 'back' function"
        execute xterm -e rcs_upview.sh -d $Node &
      fi
      leash;;

    viewErlangLog)
      viewFile /rcs/erlang/erlang.log.1 convert
      leash;;

    viewErlangLogFiltered)
      viewFile /rcs/erlang/erlang.log.1 filter
      leash;;

    viewSwmInternalLog)
      viewFile /rcs/log/SwmInternal/SwmInternal.1
      leash;;

    view)
      if [[ -z "$OldRemotePath" ]]; then
        RemotePath="`getString 'remote file'`"
      elif isSpaceFree "$OldRemotePath"; then
        RemotePath="`getString 'remote file' $OldRemotePath`"
      else
        RemotePath="`getString 'remote file'`"
      fi
      if interrupted; then continue; fi

      case "$RemotePath" in
        /*)
          AbsRemotePath="$RemotePath";;
        *)
          AbsRemotePath=/home/$DuUser/"$RemotePath"
      esac

      viewFile $AbsRemotePath
      OldRemotePath=$AbsRemotePath
      leash;;

    fetch)
      if [[ $Node == sim ]]; then
        say "not available for simulator"
      else
	TargetDir=`getString 'target directory' $TargetDirOld`
	if ! mkdir -p "$TargetDir"; then
	  warning "failed to create directory: $TargetDir"
	else
	  RemoteFilePattern="`getString 'remote file pattern' $RemoteFilePatternOld`"
	  if ! nodeScp "$ScpRemote:$RemoteFilePattern" $TargetDir; then
	    warning "failed to copy files"
	  else
	    TargetDirOld=$TargetDir
	    RemoteFilePatternOld=$RemoteFilePattern
	    say "files copied"
	  fi
        fi
      fi
      leash;;

    edit)
      if [[ $Node == sim ]]; then
        say "not available for simulator"
      else
	if [[ -z "$OldRemotePath" ]]; then
	  RemotePath="`getString 'remote file'`"
	elif isSpaceFree "$OldRemotePath"; then
	  RemotePath="`getString 'remote file' $OldRemotePath`"
	else
	  RemotePath="`getString 'remote file'`"
	fi
	if interrupted; then continue; fi
	case "$RemotePath" in
	  /*)
	    AbsRemotePath="$RemotePath";;
	  *)
	    AbsRemotePath=/home/$DuUser/"$RemotePath"
	esac
	LocalFile=`mktemp -u --tmpdir=/tmp $USER-XXXXXXXX`
	LocalFileDigest=`mktemp -u --tmpdir=/tmp $USER-XXXXXXXX`
	if nodeScp "$ScpRemote:$AbsRemotePath" $LocalFile; then
	  OldRemotePath="$AbsRemotePath"
	  openssl md5 $LocalFile | sed -e 's|.* ||' >$LocalFileDigest
	  chmod +w $LocalFile
	  ${EDITOR:-emacs} $LocalFile
	  if openssl md5 $LocalFile | sed -e 's|.* ||' | cmp --silent - $LocalFileDigest; then
	    say "No changes need to be saved."
	  else
	    if nodeScp $LocalFile $ScpRemote:"$AbsRemotePath"; then
	      rm $LocalFile
	      rm $LocalFileDigest
	    fi
	  fi
	else
	  say "Apparently the file does not exist; create it now."
	  touch $LocalFile
	  ${EDITOR:-emacs} $LocalFile
	  if nodeScp $LocalFile $ScpRemote:"$AbsRemotePath"; then
	    rm $LocalFile
	  fi
	fi
      fi
      leash;;

    insertPatch)
      if [[ -z "$OldPatchFile" ]]; then
        PatchFile=`getString 'file to insert'`
      else
        PatchFile=`getString 'file to insert' $OldPatchFile`
      fi
      if interrupted; then continue; fi
      if [[ "$Node" == sim ]]; then
        copyToDirs $PatchFile none /home/$USER/dev_patches
      elif [[ `getDuType "$Node"` == vrcs ]]; then
        copyToDirs $PatchFile $ScpRemote /home/$DuUser/dev_patches
      else
        copyToDirs $PatchFile $Node /home/$DuUser/dev_patches
      fi
      OldPatchFile=$PatchFile
      leash;;

    insertUpgradePatch)
      if [[ -z "$OldUpgradePatchFile" ]]; then
        UpgradePatchFile=`getString 'file to insert'`
      else
        UpgradePatchFile=`getString 'file to insert' $OldUpgradePatchFile`
      fi
      if interrupted; then continue; fi

      if [[ "$Node" == sim ]]; then
        mkdir -p $RcsRoot/rcs/swm/ug_patches
	copyToDirs $UpgradePatchFile none /rcs/swm/ug_patches /home/$USER/dev_patches
      elif [[ `getDuType "$Node"` == vrcs ]]; then
        nodeSsh $Node $Address mkdir -p /rcs/swm/ug_patches
	copyToDirs $UpgradePatchFile $ScpRemote /rcs/swm/ug_patches /home/$DuUser/dev_patches
      else
        nodeSsh $Node mkdir -p /rcs/swm/ug_patches
	copyToDirs $UpgradePatchFile $Node /rcs/swm/ug_patches /home/$DuUser/dev_patches
      fi
      OldUpgradePatchFile=$UpgradePatchFile
      leash;;

    cpuLoad)
      if [[ "$Node" == sim ]]; then
        say "not applicable for simulator"
      else
	copyToDirs `command -v rcs_cpuload_monitor.sh` $Node $NodeTmpDir
        execute \
          xterm -geometry 110x`getMonitorWindowHeight $DuType` \
            -T "$Node CPU load" \
            -e ssh $SshOptions $Address $NodeTmpDir/rcs_cpuload_monitor.sh -c blue \
            &
	slowSay "CPU load monitor started, type Ctrl-C in the monitor window to terminate."
      fi
      leash;;

    moshell)
      xOptions="-geometry 120x50 -bg $peachish"
      if [[ "$Node" == sim ]]; then
        moShellExtras=http_port=`getPort www`,secure_port=`getPort cli`,comcli_port=`getPort cli`
        if [[ "$securePort" == undefined ]]; then
          warning "could not determine CLI port"
        else
          Command="xterm $Scrollable $xOptions -e $Moshell -v $moShellExtras,$MoshellVarsSim localhost"
          trace $Command "&"
	  $Command &
        fi
      else
        Command="xterm $Scrollable $xOptions -e $Moshell -v $MoshellVarsTarget $Address"
	trace $Command "&"
	$Command &
      fi
      say "Moshell session launched, essential commands are:"
      say "  lt all                load MO instances"
      say "  pr                    print all MO instances"
      say "  get INSTANCE          inspect instance"
      say "  acl INSTANCE          list actions"
      say "  acc INSTANCE ACTION   execute action"
      leash;;

    verbose)
      Reply="`getString 'verbose (y/n)' 'y'`"
      if interrupted; then continue; fi
      case "$Reply" in
        y|Y|yes|Yes|YES)
          Verbose=true;;
        *)
          Verbose=false
      esac;;

    about)
      about
      say "type Ctrl-C in the pop-up window to remove it"
      leash;;

    exit)
      trap '-' INT
      # Experimental...
      # rm $HostsFile
      rm $IdleSeconds
      exit;;

    sourceLabels)
      sourceLabels
      say "type Ctrl-C in the pop-up window to remove it"
      leash;;

    power)
      power
      leash;;

    installLicense)
      installLicense
      leash;;

    logView)
      logView
      leash;;

    sftpSession)
      if [[ "$Node" == sim ]]; then
        trace xterm $Scrollable -bg $eggshell -fg black -T SFTP -e rcssim_ssh sftp "&"
        xterm $Scrollable -bg $eggshell -fg black -T SFTP -e rcssim_ssh sftp &
      else
	trace xterm $Scrollable -bg $eggshell -T SFTP -e sftp $SftpOptions $Address "&"
	xterm $Scrollable -bg $eggshell -T SFTP -e sftp $SftpOptions $Address &
      fi
      say "SFTP session launched, password is: expert"
      leash;;

    shutdown)
      if [[ `getDuType "$Node"` == vrcs ]]; then
        say "not supported on VRCS"
      elif [[ "$Node" != sim ]]; then
        say "only available with the simulator"
      else
        declare RcssimPidFile=`if [[ -n "$SimulatorPath" ]]; then echo $SimulatorPath; else echo $SimAreaDefault/$USER; fi`/rcssim.pid
        if [[ ! -f $RcssimPidFile ]]; then
          say "only available when the simulator was started with the -w option"
        else
          execute kill -INT `cat $RcssimPidFile`
          say "rcssim requested to shutdown"
        fi
      fi
      leash;;

    applog)
      doApplog
      leash;;

    *)
      fatal "unknown case: $selection"

  esac
done
