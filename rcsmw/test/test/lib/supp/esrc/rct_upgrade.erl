%%% #0.    BASIC INFORMATION
%%% ----------------------------------------------------------
%%% %CCaseFile:	rct_upgrade.erl %
%%% @author etxkols
%%% @copyright Ericsson AB 2013-2016
%%% @version /main/R2A/R4A/2
%%% @doc ==Common Test hook for getting path to upgrade package==
%%%
%%%
%%% Stores upgrade package paths using upgrade.cfg file which is generated by $RDE_TOP/bin/upgradeprep.sh.<br/>
%%%
%%% Hook formats:
%%% ```{rct_upgrade, [{N, Name}]}'''
%%%
%%% There is a short format for testing towards single node:
%%% ```{rct_upgrade, Name}  expands to 
%%%    {rct_upgrade, [{1, Name}]}'''
%%%
%%% There is a short format for testing towards clusterd nodes:
%%% ```{rct_upgrade, [Name1,Name2]}  expands to 
%%%    {rct_upgrade, [{1, Name1}, {2, Name2}]}'''
%%%
%%% Argument description:
%%% ```N        = integer()                      Used to match card in upgrade.cfg file when running on target.
%%%    Name     = atom()                         Used as identifier'''
%%% Examples:<br/>
%%% ```suite() -> 
%%%        [{ct_hooks, [{rct_upgrade,node1}]}].'''
%%%
%%% ```suite() -> 
%%%        [{ct_hooks, [{rct_upgrade,[node1, node2]}]}].'''
%%%
%%% Testcase example.
%%% ```mytest(_) ->
%%%        {ok, Path} = rct_upgrade:get_up_dir(node1).'''
%%% @end

-module(rct_upgrade).
-id('Updated by CCase').
-vsn('/main/R2A/R4A/2').
-date('2016-08-19').
-author('etxkols').
%%% ----------------------------------------------------------
%%% %CCaseTemplateFile: module.erl %
%%% %CCaseTemplateId: 53/002 01-LXA 119 334 Ux, Rev: /main/4 %
%%% 
%%% %CCaseCopyrightBegin%
%%% Copyright (c) Ericsson AB 2013-2016 All rights reserved.
%%% 
%%% The information in this document is the property of Ericsson.
%%% 
%%% Except as specifically authorized in writing by Ericsson, the 
%%% receiver of this document shall keep the information contained 
%%% herein confidential and shall protect the same in whole or in 
%%% part from disclosure and dissemination to third parties.
%%% 
%%% Disclosure and disseminations to the receivers employees shall 
%%% only be made on a strict need to know basis.
%%% %CCaseCopyrightEnd%
%%%
%%% ----------------------------------------------------------
%%% #1.    REVISION LOG
%%% ----------------------------------------------------------
%%% Rev        Date       Name        What
%%% -----      ---------  --------    ------------------------
%%% R2A/1      2013-04-09 etxkols     Created
%%% R2A/2      2014-03-26 etxkols     Faulty init/2 return value
%%% R3A/1      2015-05-28 etxkols     Cluster fixes
%%% ----------------------------------------------------------
%%% 
%%% #2.    EXPORT LISTS
%%% ----------------------------------------------------------
%%% #2.1   EXPORTED INTERFACE FUNCTIONS
%%% ----------------------------------------------------------

-export([init/2,
	 pre_init_per_suite/3,
	 terminate/1,
	 get_up_dir/1]).

-include_lib("common_test/include/ct.hrl").


%%===========================================================================
%% @spec get_up_dir(Name) ->
%%    {ok, Path} | {error, Reason}
%% Name = atom()
%% Path = string()
%% Reason = term()
%%
%% @doc Gets path to upgrade package.<br/>
%% Example: 
%% ```rct_upgrade:get_up_dir(node1). -> "/proj/rcs-tmp/upgrade/dus014"'''
get_up_dir(Name) ->
    UName = make_name_module(Name),
    case ct:get_config(UName) of
        [{upgrade_path, Path}] ->
            {ok, Path};
        Other ->
            {error, Other}
    end.   

%%% @hidden
%%% init function for ct_hook
init(_Id, Opts) ->
    {ok,Opts}.

%% @hidden
%%===========================================================================
%% @spec pre_init_per_suite(Suite, Config, States) -> 
%%    {Config, States} | {{fail,Reason}, States}
%%
%% @doc Checks that upgrade_UP_paths exists in upgrade.cfg.<br/>
pre_init_per_suite(_Suite, {SkipOrFail, _Reason} = Ret, CthState) 
  when SkipOrFail =:= skip; SkipOrFail =:= fail ->
    {Ret, CthState};
pre_init_per_suite(Suite,Config,Name) when is_atom(Name) ->
    pre_init_per_suite(Suite,Config,[Name]);  
pre_init_per_suite(_Suite,Config,CthState) ->
    SuiteType = case length(CthState) > 1 of
    		    true  -> clustered;
    		    false -> single
    		end,
    case do_pre_init_per_suite(CthState, SuiteType, 1) of
	ok ->                       
	    {Config, CthState};
	Other ->
	    Other
    end.

do_pre_init_per_suite([],_SuiteType,_Num) ->
    ok;
do_pre_init_per_suite([Name|T],SuiteType,Num) when is_atom(Name) ->
    do_pre_init_per_suite([{Num,Name}|T],SuiteType,Num);
do_pre_init_per_suite([{N, Name}|T], SuiteType, Num) ->
    case ct:get_config({upgrade_UP_paths, N}) of
	undefined ->
	    ct:log(lightred,"~p: ~p ~p Could not get config parameter ~p, Reason: ~p",
		   [Name, ?MODULE, do_pre_init_per_suite,[{upgrade_UP_paths, N}], undefined]),
			    {{fail, could_not_initate_upgrade}, [Name]};
	Path ->
	    case rct_multi_node_cfg:require(make_name_module(Name),
					    [{upgrade_path,Path}]) of
		ok ->
		    do_pre_init_per_suite(T, SuiteType, Num + 1);
		{error, Reason} ->
		    ct:log(lightred,"~p: ~p ~p Could not initiate config parameter ~p, Reason: ~p",
			   [Name, ?MODULE, do_pre_init_per_suite,[{upgrade_path,Path}], Reason]),
		    {{fail, could_not_initate_upgrade}, [Name]}
	    end
    end.

%%% @hidden
terminate(CthState) ->
    do_terminate(CthState).

do_terminate([]) ->
    ok;
do_terminate([Name|T]) when is_atom(Name) ->
    rct_multi_node_cfg:remove_config(make_name_module(Name)),
    do_terminate(T);
do_terminate([{_,Name}|T]) ->
    rct_multi_node_cfg:remove_config(make_name_module(Name)),
    do_terminate(T).

make_name_module(Name) ->
    list_to_atom(atom_to_list(Name) ++ "_" ++ atom_to_list(?MODULE)).
