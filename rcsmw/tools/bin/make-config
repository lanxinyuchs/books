#!/usr/bin/env python
# FILE:
#
# ABSTRACT:
#   PDU Platform CI -
#
# COPYRIGHT:
# Copyright (C) 2014 by Ericsson AB, SWEDEN
#
# The program may be used and/or copied only with the written permission from
# Ericsson AB, or in accordance with the terms and conditions stipulated in
# the agreement/contract under which the program has been supplied.
#
# All rights reserved.
#
"""
Prits a delivery configuration file suitable for giving as argument
to publish.py, located in ciutils. It extracts the URL from the
event repository using REST API calls to the ER_URL. The ci module must
be sourced before executing this program.

Usage:
  make-config [options] CONFIG_FILE ARTIFACT VERSION [ OUTFILE ]
  make-config -h | --help

Arguments:
  CONFIG_FILE              path to a delivery.config file
  ARTIFACT_ID              product number with underscores
  VERSION                  product version
  OUTFILE                  file to save data in. stdout is used if omitted

Options:
  -d --debug               print debug information. Takes precedence over -v
  --er-url URL             Event Repository rest API URL
  -h --help                show this
  -v --verbose             print verbose information

Variables:
  ER_URL                   Event Repository default rest API URL

Example:
  # Run program verbosly
  > make-config delivery.config CXP1234567_2 P1A01 CXP1234567_2-delivery.config

"""
import ast
import contextlib
import os
import subprocess
import sys
from subprocess import check_output, CalledProcessError

if sys.version_info < (2, 7):
    sys.exit(("Sorry, this script only works"
              " on Python 2.7 or greater. Please check if"
              " there is a newer version available via 'module'."))

import logging
import ConfigParser
from pprint import pformat

try:
    from docopt import docopt
except ImportError:
    logging.error("The 'utils' and 'docopt' "
                  "module are located in the cpp/tools/integration repository")
    raise


@contextlib.contextmanager
def fs_open(file=None):
    if file and file != '-':
        fh = open(file, 'w')
    else:
        fh = sys.stdout
    try:
        yield fh
    finally:
        if fh is not sys.stdout:
            fh.close()


def get_artifact_url(artifact, version, er_url=None):
    """
    Return the URL in an ArtifactNewEvent for the given artifact and version.
    """
    if er_url:
        command = ['er_client.py', '--uri', er_url, '-f', 'packageurl',
                   'findArtifactNewEvent',
                   'artifactId={}'.format(artifact),
                   'version={}'.format(version)]
    else:
        command = ['er_client.py', '-f', 'packageurl', 'findArtifactNewEvent',
                   'artifactId={}'.format(artifact),
                   'version={}'.format(version)]
    logging.debug('Calling: {}'.format(' '.join(command)))
    return check_output(command, stderr=subprocess.STDOUT)


def parse_arguments(raw_args):
    """
    Using the module doc string to generate a parser and parse the command
    line input
    """
    args = docopt(__doc__, argv=raw_args)
    if args["--debug"]:
        logging.getLogger().setLevel(logging.DEBUG)
    elif args["--verbose"]:
        logging.getLogger().setLevel(logging.INFO)

    if not args['--er-url']:
        args['--er-url'] = os.getenv('ER_URL', None)
    logging.debug("Command line arguments: %s", pformat(args))
    return args


def main(args):
    """ Main function """
    try:
        config = ConfigParser.ConfigParser()
        config.read([args['CONFIG_FILE']])
        config.set(args['ARTIFACT'], 'version', args['VERSION'])
        config.set(args['ARTIFACT'], 'url',
                   get_artifact_url(args['ARTIFACT'], args['VERSION'],
                                    args['--er-url']))
        with fs_open(args['OUTFILE']) as outfile:
            outfile.write("[{}]\n".format(args['ARTIFACT']))
            for k, v in config.items(args['ARTIFACT']):
                outfile.write("{} = {}\n".format(k, v))
    except ConfigParser.NoSectionError as e:
        sys.exit('Error: {}'.format(e.message))
    except CalledProcessError as e:
        sys.exit(
            "Error: er_client.py failed to find a matching ArtifactNewEvent. Error was:\n{}".format(
                e.output))


if __name__ == '__main__':
    main(parse_arguments(sys.argv[1:]))