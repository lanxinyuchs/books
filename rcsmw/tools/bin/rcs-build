#!/usr/bin/env bash

# Build a VRCS MW product.
#
# Sourcing the env-i586.sh file may disturb the user's shell, e.g. "tig" will
# stop working. This is due to cross-compiling settings. This program wraps
# the builds so that the user does not need to source the env file, and keep
# the shell unaffected.

set -euo pipefail

# Print basic usage information
#

print_usage () {
    echo "Usage: $(basename $0) [ <options> ] <product> [ -- <waf options>... ]"
    echo "  Build the RCS products"
    echo "Options:"
    echo "  --clean:       run \"waf clean\" for the given target and exit"
    echo "  --help:        show this help"
    echo "  --[no]image:   build qcow2 image. Implies --package. [default: --image]"
    echo "  --man-page:    display the man page"
    echo "  --[no]package: package the built product [default: --package]"
    echo "  --printenv:    print the environment after sourcing the setup"
    [[ ${1-} ]] && exit
}

# Declared variables

args=''
clean=''
image='1'
package='1'
printenv=''

# Parse options
#

handle_options () {

    # Program options
    GETOPT=$(getopt --options '+hm' --long clean,help,image,noimage,man-page,package,nopackage,printenv -n $0 -- "$@")

    if [[ $? != 0 ]] ; then echo "Error parsing arguments." >&2 ; exit 1 ; fi

    eval set -- "$GETOPT"

    while true ; do
        case "$1" in
          --clean) clean=1;;
          --help) print_usage exit;;
          --image) image=1;;
          --noimage) image='';;
          --man-page) print_man_page; exit ;;
          --package) package=1;;
          --nopackage) package='';;
          --printenv) printenv=1;;
          --) shift ; break ;;
          *) echo "Internal error! Unexpected argument \"$1\"" ; exit 1 ;;
        esac
        shift
    done

    # $@ is local since we are in a function. Copy it to the global variable.
    args="$@"
}

# Build the RCS
# Args: <target>

build_rcs() {
    target=$1
    shift
    set +u
    source $TOPDIR/env-$target.sh
    set -u
    [[ $clean ]]    && exec $TOPDIR/waf clean
    [[ $printenv ]] && (printenv | sort)

    $TOPDIR/waf "$@"

    if [[ $image ]]; then
        $TOPDIR/tools/package.sh --image
    elif [[ $package ]]; then
        if [[ "$target" == "msrcs" ]]; then
            $TOPDIR/tools/package-g2.sh
        else
            $TOPDIR/tools/package.sh
        fi
    fi
}


# Print the content of the given key if it exists in the config file, removing
# any "@" characters
# param 1: artifact id
# param 2: key
# param 3: config file to read from
function read_key() {
    # config.py returns error exit status if the key does not exist, which
    # is the reason this function is needed.
    local config_file=${3}
    for key in $1 $1-extras; do
        if config.py exists $config_file $key $2; then
            config.py read $config_file $key $2 | sed -e 's/@//g'
        fi
    done
}


# Patch latest Node UP for use with JCAT
#
# Param $1: Track, e.g. main
# Param $2: Node UP product number
# Param $3: Id of the patched UP, e.g. TEST_CXP9029198_1
# param $@: Paths to modules to replace

patch_node_up() {
    [[ ${1-} ]] || die "Error: delivery.config file argument is missing for patch_node_up()"
    [[ ${2-} ]] || die "Error: Track argument is missing for patch_node_up()"
    [[ ${3-} ]] || die "Error: target UP product number missing for patch_node_up()"
    local config=$1
    local track=$2
    local release=$(basename $track)
    local id=$3
    local name=$(read_key $id artifact $config)

    local up_number=$(read_key $id upbase $config)
    local modules=$(read_key $id modules $config)

    [[ $modules ]] || die "$config: Error: empty or non-existing key \"modules\" in section $id"

    local outdir=$TOPDIR/out
    local tmpdir=$TOPDIR/patch-up.tmp
    rm -rf $tmpdir
    mkdir -p $tmpdir

    modulesopt=''
    for m in $modules; do
        fullname=$(read_key $m artifact $config)
        extension=$(read_key $m extension $config)
        [[ $fullname ]] || die "Error: unable to determine full name for artifact $m"
        cp out/$fullname.$extension $tmpdir
        modulesopt="$modulesopt -module $fullname.$extension"
    done

    local version=$(./tools/bin/get_latest_cxp.sh $up_number 3 $track)
    local packageurl=$(er_client.py -f packageurl findArtifactNewEvent artifactId=$up_number version=$version)
    local filename=$(basename $packageurl)

    pushd $tmpdir > /dev/null

    echo Creating patched Node UP for $up_number-$version with $modules

    wget "$packageurl" -O $filename

    local prodnr=${name#*_}

    if [[ ${BUILD_TAG-} ]]; then
        local rev=$(rstatef_ci --project $PROJECT --track $TRACK $prodnr)
    else
        local rev=P1A01
    fi

    set -x
    temp=$(mktemp -d --tmpdir=.)
    cd $temp
    unzip ../$filename C*xml
    TYPE=$(egrep "<type>" CXP*xml | cut -f2- -d\> | cut -f1 -d\<)
    cd ..
    rm -rf $temp

    /env/rbsg2/bin/ncgen -zip -id $id -rev $rev -node $filename $modulesopt -release $release -type $TYPE
    mv -f $id.zip $outdir/$name.zip

    echo $prodnr $rev >> $outdir/baseline.txt
    echo -e "[$prodnr]\nversion=$rev\n" >> $outdir/baseline.config

    rm -f ${outdir}/$(cicd get-id-lc $id).xml
    generate-delivery-xml $id ${outdir}/$(cicd get-id-lc $id).xml
    echo -e "[$prodnr]\ndeliveryxml=${outdir}/$(cicd get-id-lc $id).xml" >> $outdir/baseline.config


    popd > /dev/null

    if [[ ${image-} ]]; then
        build-image $outdir/$name.zip $outdir/$name.qcow2
    fi
}

# Patch latest JCAT testcode to be linked to BRCS/VRCS
#
# Param $1: config file delivery.config
# Param $2: Track, e.g. main
# Param $3: Id of the JCAT testcode, e.g. CXP2030012_1

patch_testcode() {
    [[ ${1-} ]] || die "Error: delivery.config file argument is missing for patch_testcode()"
    [[ ${2-} ]] || die "Error: Track argument is missing for patch_testcode()"
    [[ ${3-} ]] || die "Error: product number of the JCAT testcode, e.g. CXP2030012_1 missing for patch_testcode()"
    local config=$1
    local track=$2
    local release=$(basename $track)
    local id=$3

    # confidence level
    local cl=0
    local version=$(./tools/bin/get_latest_cxp.sh $id $cl $track)
    local outdir=$TOPDIR/out


    # store [CXP2030012_1],$version to out/baseline.config
    echo $id $version >> $outdir/baseline.txt
    echo -e "[$id]\nversion=$version\n" >> $outdir/baseline.config

    echo -e "cat $outdir/baseline.config"
    cat $outdir/baseline.config

}

# Patch latest Node UP for use with JCAT
# This is temporary, as we need to switch product numbers also.
# Use the function above when you only want to switch revision
#
# Param $1: Track, e.g. main
# Param $2: Node UP product number
# Param $3: Id of the patched UP, e.g. TEST_CXP9029198_1
# param $@: Paths to modules to replace

patch_node_up_temp() {
    set -x
    [[ ${1-} ]] || die "Error: delivery.config file argument is missing for patch_node_up_temp()"
    [[ ${2-} ]] || die "Error: Track argument is missing for patch_node_up_temp()"
    [[ ${3-} ]] || die "Error: target UP product number missing for patch_node_up_temp()"
    local config=$1
    local track=$2
    local release=$(basename $track)
    local id=$3						# eg. CXP2010043_1
    local name=$(read_key $id artifact $config)		# eg. TEST_CXP2010043_1

    local up_number=$(read_key $id upbase $config)	# This is the new, patched UP number, our output, eg. CXP9024418_6
    local modules=$(read_key $id modules $config)
    local replace=$(read_key $id replace $config)
    local baseband_name=$(read_key $id baseband $config)
    local type=$(read_key $id type $config)
    local relea=$(read_key $id release $config)

    local outdir=$TOPDIR/out
    local tmpdir1=$TOPDIR/patch-up.tmp1
    rm -rf   $tmpdir1
    mkdir -p $tmpdir1

    [[ $modules ]] || die "$config: Error: empty or non-existing key \"modules\" in section $id"

    local version=$(./tools/bin/get_latest_cxp.sh $up_number 3 $track)
    local packageurl=$(er_client.py -f packageurl findArtifactNewEvent artifactId=$up_number version=$version)
    local filename=$(basename $packageurl)

    pushd $tmpdir1 > /dev/null

    echo Creating patched Node UP for $up_number-$version with $modules

    wget "$packageurl" -O $filename

    unzip $filename
    # Remove the old, CC products
    for module in $replace; do
        rm $module
    done

    # Add the new, git products
    for module in $modules; do
        cp ${TOPDIR}/out/*${module}.cxp .
    done


    local prodnr=${name#*_}

    if [[ ${BUILD_TAG-} ]]; then
        local rev=$(rstatef_ci --project $PROJECT --track $TRACK $prodnr)
    else
        local rev=P1A01
    fi

    set +x
    cd $TOPDIR/out
    /env/rbsg2/bin/ncgen_global --path $tmpdir1 --id $id --name $baseband_name --rev $rev --project G2 --track main --infobank_lookup True -type $type -release $relea
    mv -f $id.zip $name.zip

    echo $prodnr $rev >> $outdir/baseline.txt
    echo -e "[$prodnr]\nversion=$rev" >> $outdir/baseline.config

    popd > /dev/null
}

# Emits the arguments on stderr and exits the script
# param: text to print [optional]

die() {
    echo "$@" 1>&2
    exit 1
}

# Main program.

main () {
    export TOPDIR=${TOPDIR:-$(readlink -f $(dirname $0)/../..)}

    [[ ${1:-} ]] || print_usage exit

    product=$1
    shift

    product=${product//\//_}
    case $product in
    VRCS)
        build_rcs vrcs "$@"
        patch_node_up tools/config/delivery.config DURA/$PROJECT/$TRACK CXP9033686_5
        ;;
    VRCS64)
        build_rcs vrcs64 "$@"
        patch_node_up tools/config/delivery.config DURA/$PROJECT/$TRACK CXP2010039_1
        patch_node_up tools/config/delivery.config DURA/$PROJECT/$TRACK CXP2010040_1
        ;;
    BRCS)
        image=''
        build_rcs brcs "$@"
        patch_node_up tools/config/delivery.config DURA/$PROJECT/$TRACK CXP9033685_5
	patch_testcode tools/config/delivery.config DURA/$PROJECT/$TRACK CXP2030012_1
        ;;
    MSRCS)
        image=''
        build_rcs msrcs "$@"
        patch_node_up_temp tools/config/delivery.config DURA/$PROJECT/$TRACK CXP2010043_1
        patch_node_up_temp tools/config/delivery.config DURA/$PROJECT/$TRACK CXP2010044_1
        ;;
    *)
        echo $product: Error: unknown product 1>&2
        exit 1;;
    esac
}


######################################################################
### Man page should be the last part in the file

print_man_page () {
    if [[ ! ${PAGER-} ]]; then
        export PAGER=less
    fi

    if perldoc -l Term::ANSIColor > /dev/null 2>&1; then
        color=--color
    fi

    ( pod2text --loose $color - <<EOPOD

=head1 NAME

$(basename $0) - build the BRCS or VRCS products

=head1 SYNOPSIS

$(basename $0) [B<--options>] I<target> [I<waf options>...]

=head1 DESCRIPTION

Run a build and package of I<all> of the VRCS or BRCS CXP, CXA, and CXS
products. The build result will be stored in the F<\${TOPDIR}/out> directory.
The required environment will be sourced automatically.

=head1 ARGUMENTS

Products may be specified by number, name, or both name and number. Slashed
numbers may be specified with slashes or underscore.

Examples building the VRCS products:

    rcs-build VRCS-UP
    rcs-build CXS101657/4
    rcs-build CXP9029176_4

Examples building the BRCS products:

    rcs-build BRCS-UP
    rcs-build CXS101665_3

=head1 OPTIONS

=over 4

=item B<--clean>

Run "waf clean" for the given product and exit

=item B<--help>

Print short help text

=item B<--man-page>

Show this man page

=item B<--[no]package>

Whether to package the products after build. Default is B<--package>

=item B<--printenv>

Print the environment after sourcing the setup file for the target.

=back

=head1 SEE ALSO

-

EOPOD
  ) | $PAGER
}

# The sole purpose of the calls below is to allow the man page to stay at the end
# of the file

handle_options "$@"
main $args
