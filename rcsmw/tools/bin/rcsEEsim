#!/bin/bash
# ----------------------------------------------------------------------
# %CCaseFile:	rcsEEsim %
rev="%CCaseRev:	/main/76 %"
# %CCaseDate:	2016-04-18 %
# Author:	etxarnu/etxbjca
#
# Short description: Start, stop and status of rcs simulated EE parts
#
# ----------------------------------------------------------------------
#
# %CCaseCopyrightBegin%
# Copyright (c) Ericsson AB 2012-2016 All rights reserved.
# 
# The information in this document is the property of Ericsson.
# 
# Except as specifically authorized in writing by Ericsson, the 
# receiver of this document shall keep the information contained 
# herein confidential and shall protect the same in whole or in 
# part from disclosure and dissemination to third parties.
# 
# Disclosure and disseminations to the receivers employees shall 
# only be made on a strict need to know basis.
# %CCaseCopyrightEnd%
#
#----------------------------------------------------------------------
# #1.    REVISION LOG
#----------------------------------------------------------------------
# Rev      Date       Name        What
# -----    -------    --------    -------------------------------------
# main/1   2012-07-21 etxarnu     Created
# main/33  2013-06-18 etxarnu     Added ITC to LD_LIBRARY_PATH
# main/44  2013-10-07 etxarnu     Reverted back to LINXNS
#                                 Enabled LTTNG
# main/46  2013-10-16 etxarnu     New try with NSNG
#                                 Removed startLttTri call i restartUsel
#                                 Added option startTri which will do a startLttTri
# main/50  2013-11-27 etxarnu     Added PGH_CWD so core dumps work in simulated
# main/51  2013-12-20 etxarnu     Added COLI_CMDS_PATH
# main/53  2014-03-18 etxarnu     Added start of TED
# main/56  2013-03-21 etxarnu     Reverted back to /52
# main/57  2014-03-25 etxarnu     Added start of TED and TE_LTTNG env variables
# main/59  2014-03-26 etxarnu     Adjusted start of TRI channels
# main/65  2014-04-09 etxarnu     stopLttngTri is now called at restartUsel
# main/66  2014-05-06 etxarnu     Cleanup and prepare for proot/itcworld
# main/67  2014-06-04 erarafo     HS66696, Fuzzy lookup of process pids
# main/68  2014-06-05 erarafo     Minor corrections
# main/69  2014-06-27 erarafo     Use pghd from RHAI2 if exist
# main/71  2014-09-04 etxarnu     Removed XTED
# main/72  2014-10-15 etxarnu     Removed ELINX/LINX/LINX-NS and Usel
#
#set -x

#  Help functions

function Usage () {
cat <<EOF

RB CS Execution Environment simulator
=====================================

Use rcsEEsim to start/stop/restart and get status:

rcsEEsim status  - shows status of ITC and daemons

rcsEEsim stopUsel    - stops daemons and ITC

rcsEEsim startUsel   - starts ITC and daemons

rcsEEsim restartUsel - stop + start with ITC


EOF
}

# installPrefix absPath
#
# The given absPath is the absolute path of a program that
# executes on the simulator.
#
# A directory prefix is returned that reflects the simulator
# installation path. For a default installation the path
# /local/scratch/$USER is likely to be returned.

function installPrefix() {
  local -r absPath="$1"
  echo $absPath | sed -e "s|/RCS_ROOT/home/$USER/software/.*||"
}

# getMatchingPids fuzzyAbsPath
#
# Returns the pids of running programs that match the given
# absPath. An exact match is not required; it is only required
# that the basename and the probable simulator installation
# paths match.

function getMatchingPids() {
  local -r fuzzyAbsPath="$1"
  local -r basename=${fuzzyAbsPath##*/}
  local -r candidatePids=`pgrep -u $USER $basename`
  local absPath
  for pid in $candidatePids; do
    absPath=`ps -p $pid --no-headers -o args | (read firstWord _ && echo $firstWord)`
    if [[ ${absPath##*/} == $basename && \
          `installPrefix $absPath` == `installPrefix $fuzzyAbsPath` ]]; then
      echo $pid
    fi
  done
}

#ensure that the argument $1 which is expected to contain metacharacters for
#file-expansion resolves to a directory and only one directory
#Exit with error if unsuccesful
function resolve_dir_path_int() {
	local in_path="${1}"
	set -- $1
	if [ $# -ne 1 -o  ! -d ${1} ]; then
		echo ""
	else
	    echo ${1}
	fi
}

# Check if directory exist in dev_patches and then ordinary
function resolve_dir_path() {
    local in_path="$RCS_CODE_ROOT/${1}"
    local dev_path="$DEV_PATCHES/${1}"

    if [ "$(resolve_dir_path_int $dev_path)" != "" ]; then
	echo $dev_path
    elif [ "$(resolve_dir_path_int $in_path)" = "" ]; then
	start_log "Couldn't resolve path: ${in_path}"
	echo ""
    else
	echo $in_path
    fi
}

#
# Find patched version of a file.
# for now there is only one single dir we look in
#
function find_patch() {
    local file=${1##*/} #get the basename
    local dev=${DEV_PATCHES}/${file}
    local patch

    for patch in $dev; do
        if [ -f $patch ]; then
            echo $patch
            return 0
        fi
    done
    echo ${1}
}


function start_log() {
    D=`date +%T`
    printf "$D: %s\n" "$*" >&2
}


function is_integer() {
    [ "$1" -eq "$1" ] > /dev/null 2>&1
    return $?
}


function stopOneDaemon {
        local -r fuzzyAbsPath="$1"; shift
        local -r pids=`getMatchingPids $fuzzyAbsPath`
        local -r basename=${fuzzyAbsPath##*/}
        if [[ -z "$pids" ]]; then
          start_log "No process to kill for: $basename"
        elif [[ `echo $pids | wc --words` > 1 ]]; then
	  start_log "Killing $basename with pids: `echo $pids`"
          kill -KILL $pids
        else
	  start_log "Killing $basename with pid: $pids"
          kill -KILL $pids
        fi
}

# This function is currently not used!

function stopOneDaemon2 {
	local daemon="${1}"
	local name=${1##*/} #get the basename
	pids=`pgrep -f ${daemon}`
	for pidProc in ${pids}
	do
	    start_log "Killing ${name} with pid  ${pidProc}"
	    kill -9  "${pidProc}" 2>/dev/null
	done
}

# This function is currently not used!

function stopOneDaemon1 {
	local daemon="${1}"
	local name=${1##*/} #get the basename
	if [ -s  ${PID_DIR}/${name}.pid ]
	then
	    for pid in $(cat ${PID_DIR}/${name}.pid)
	    do
		if is_integer "${pid}"; then
		    pidProc=`ps -fww -p "${pid}" |grep  "${USER}" |grep ${name} |grep "${installDir}" | awk '{print $2}'`
		    if [  "${pidProc}" != "" ]
		    then
			start_log "Killing ${name} with pid  ${pidProc}"
			kill -9  "${pid}" 2>/dev/null
		    fi
		fi
	    done
	    rm  ${PID_DIR}/${name}.pid
	fi
}

# This function stops daemons
#
function stopDaemons {
    start_log "Stopping RBS CS EE daemons"
    stopOneDaemon ${ITCGW}
    stopOneDaemon ${LTTNGD}
    stopOneDaemon ${PGHD}
    stopOneDaemon ${NSD}
    stopOneDaemon ${TED}
    stopOneDaemon ${TRID}
    stopOneDaemon ${COLID}
    sleep 2
    stopOneDaemon ${ITCD}
 }


function stopEEall {
    start_log "Killing all ITCGW"
    pkill -9  -u ${USER} itcgw 2> /dev/null
    start_log "Killing all LTTNGD"
    pkill -9  -u ${USER} lttng-sessiond 2> /dev/null
    start_log "Killing all PGHD"
    pkill -9  -u ${USER} pghd 2> /dev/null
    start_log "Killing all TRID"
    pkill -9 -u ${USER} trid 2> /dev/null
    start_log "Killing all COLID"
    pkill -9  -u ${USER} colid 2> /dev/null
    start_log "Killing ITCD"
    pkill -9  -u ${USER} itcworld 2> /dev/null
    start_log "RBS CS simulated EE stopped"
}

function startItc {
    start_log "Starting ITCWORLD with"
    start_log "ITC_RUNDIR_PATH = $ITC_RUNDIR_PATH"
    start_log "ITC_INSTANCE_NAME = $ITC_INSTANCE_NAME"
    rm -rf $ITC_RUNDIR_PATH/*
    startOneDaemon ${ITCD} 1
}


function killDaemon {
    local daemon="${1}"
    local name=${1##*/} #get the basename
    pid=`ps -efwww | grep ${daemon} | grep -v grep | awk '{print $2}'`
    if [  "${pid}" != "" ]
    then
	start_log "Killing ${name} with pid  ${pid}"
	kill -9  "${pid}" 2>/dev/null
    fi
}

function startOneDaemon {
	local daemon="${1}"
	local sleepTime="${2}"
	local args="${3:-""}"
	local name=${1##*/} #get the basename

	if pgrep -l -u $USER -f ${daemon} >& /dev/null
	then
    	    start_log "${name} daemon already started, killing it"
	    killDaemon ${daemon}
	fi
	start_log "Starting ${name} ${args} daemon"
	${daemon} ${args} &

	sleep .2
	pid=`ps -efwww | grep ${daemon} | grep -v grep | awk '{print $2}'`
	cnt=0
	until
	[  "$pid" -o $cnt -gt 20 ]
	do
	    cnt=$[$cnt + 1]
	    echo -n $pid "."
	    sleep .1
	    pid=`ps -efwww | grep ${daemon} | grep -v grep | awk '{print $2}'`
	done
#	start_log
	if [ $cnt -gt 20 ]; then
	    start_log "#####  Failed to start $daemon  ####"
	else
	    echo $pid > ${PID_DIR}/${name}.pid
	    start_log "Started ${name} daemon:"
	    pgrep -l -u $USER -f ${daemon}
	    echo
	fi

}
function startDaemons {
    start_log "Starting RBS CS EE daemons"

    pghd_portnumber=`grep pghd ${RCS_ROOT}/home/$USER/releases/*/port.conf |awk -F, '{print $2}'|awk -F\} '{print $1}'`
    uselgws_portnumber=`grep linxgws ${RCS_ROOT}/home/$USER/releases/*/port.conf |awk -F, '{print $2}'|awk -F\} '{print $1}'`
 # Create linxgws configuration
    cat <<EOF > $USEL_LOG_DIR/linxgws.conf
GATEWAY_NAME=test
INTERFACE_NAME=lo
PUBLIC_PORT=$uselgws_portnumber
EOF
    CONSDP=$ROOTFS


    startOneDaemon ${COLID} 1
    startOneDaemon ${LTTNGD} 1 "-d --no-kernel --consumerd32-path $LTTNGCONSD --consumerd32-libdir $LTTNGCONSDLIB "
    startOneDaemon ${TRID} 4
    startOneDaemon ${TED} 3
    startLttTri
    startOneDaemon ${NSD} 0.1
    startOneDaemon ${PGHD} 0.1 "-p $pghd_portnumber -e $PGH_APPENV_FILE"
    startOneDaemon ${ITCGW} 0.1 "$USEL_LOG_DIR/linxgws.conf"


    start_log "RBS CS simulated EE started"
}

function getEEStatus {
    itccmd -n -l
    echo
    start_log "Status of ITC daemon:"
    pgrep -l -u $USER -f ${ITCD}
    echo
    start_log "Status of ITCGW daemon:"
    pgrep -l -u $USER -f ${ITCGW}
    echo
    start_log "Status of COLID daemon:"
    pgrep -l -u $USER -f ${COLID}
    echo
    start_log "Status of TED daemon:"
    pgrep -l -u $USER -f ${TED}
    echo
    start_log "Status of TRID daemon:"
    pgrep -l -u $USER -f ${TRID}
    echo
    start_log "Status of NS daemon:"
    pgrep -l -u $USER -f ${NSD}
    echo
    start_log "Status of PGHD daemon:"
    pgrep -l -u $USER -f ${PGHD}
    echo
    start_log "Status of LTTNGD daemon:"
    pgrep -l -u $USER -f ${LTTNGD}
    echo
}

function startLttTri {
    sleep 2  # wait a while to let lttng be started
    start_log " **** LTTng configuration ****"
#    echo "Status of lttngd is"
#    pgrep -l -u $USER -f lttng-sessiond
    ${LTTNG} create $LTTNG_DEF_SES_NAME --snapshot -o $LTTNG_TELOG_PATH > /dev/null 2>&1
    if [ $? -ne 0 ];then
	echo "Failed to create lttng session. Trying to start it again "
	startOneDaemon ${LTTNGD} 1 "-d --no-kernel --consumerd32-path $LTTNGCONSD --consumerd32-libdir $LTTNGCONSDLIB "
	${LTTNG} create $LTTNG_DEF_SES_NAME --snapshot -o $LTTNG_TELOG_PATH
        if [ $? -ne 0 ];then
	    echo "Failed to create lttng session again. Status of lttngd is"
	    pgrep -l -u $USER -f ${LTTNGD}
	    return
	fi
    fi
    ${LTTNG} enable-event -u -a -s $LTTNG_DEF_SES_NAME --loglevel TRACE_INFO
    ${LTTNG} enable-event com_ericsson_trithread:* -u -s $LTTNG_DEF_SES_NAME
    ${LTTNG} enable-event com_ericsson_triobjif:* -u -s $LTTNG_DEF_SES_NAME
    ${LTTNG} start $LTTNG_DEF_SES_NAME
    start_log " *** LTTng configuration done ****"
    echo
}

function stopLttTri {
    echo " *** LTTng shutdown"
    ${LTTNG}  stop $LTTNG_DEF_SES_NAME >& /dev/null
    ${LTTNG}  destroy $LTTNG_DEF_SES_NAME >& /dev/null
}


##########################################################################################
##########################################################################################
##########################################################################################
#
#                     MAIN starts here
#
##########################################################################################
##########################################################################################
##########################################################################################
DEFDIR=/local/scratch
RCS_ROOT=${RCS_SIM_ROOT:-$DEFDIR/${USER:?Environment variable USER must be set}/RCS_ROOT}
CODE_ROOT=${CODE_ROOT:- ${RCS_ROOT}/home/${USER:?Environment variable USER must be set}/software}
DEV_PATCHES=${RCS_ROOT}/home/${USER}/dev_patches
PID_DIR=${RCS_ROOT}/rcs/run

PGH_APPENV_FILE=${RCS_ROOT}/pgh.appenv

export LTTNG_HOME=${RCS_ROOT}/rcs/lttng
export LTTNG_TRI_CHN_NAME=ch_tri
export LTTNG_TELOG_PATH=${LTTNG_HOME}/tri/telog
export PFS_PATH=${LTTNG_HOME}/tri
export PGH_CWD=${RCS_ROOT}

export LTTNG_DEF_SES_NAME=rcs
export LTTNG_DEF_CHN_NAME=ch_rcs
export LTTNG_DEF_OUTPUT=${LTTNG_HOME}/default

export TE_LTTNG_SNAPSHOT_PATH=${LTTNG_TELOG_PATH}
export COLI_CMDS_PATH=${RCS_ROOT}/colish

echo "TE_LTTNG_SNAPSHOT_PATH=${LTTNG_TELOG_PATH}"  > $PGH_APPENV_FILE
echo "TE_LTTNG_SESSIONS=rcs"  >> $PGH_APPENV_FILE

start_log "############################################"
start_log "rcsEEsim rev: $rev"

if [ -n "${installDir}" ]; then
    start_log "InstallDir is set to ${installDir}"
else
    if [ -d "$DEFDIR/" ]; then
	installDir=$DEFDIR/${USER}
    elif [ -d "/repo/" ]; then
	installDir=/repo/${USER}
    else
	installDir=/tmp/${USER}
    fi
fi
#export OTP_ROOT=${OTP_ROOT:-${installDir}/OTP}
export OTP_ROOT=${installDir}/OTP
export ERL_CALL=`readlink -f ${OTP_ROOT}/lib/erl_interface-*/bin/erl_call`
export ERLDIR=`readlink -f ${OTP_ROOT}/bin`
RCS_CODE_ROOT="$CODE_ROOT/RCS*_CXP2010042_*"


ITC="$(resolve_dir_path "ITC2_CXC1736334_2/itc*/priv/x86")"
LITS="$(resolve_dir_path "LIBLITS2_CXC1734538_2/liblits*/priv/x86")"
SDS="$(resolve_dir_path "LIBSDS2_CXC1734539_2/libsds*/priv/x86")"
COLI="$(resolve_dir_path "COLI2_CXC1734536_2/coli*/priv/x86")"
#XTE="$(resolve_dir_path "XTE2_CXC1734541_2/xte*/priv/x86")"
TRI="$(resolve_dir_path "TRI2_CXC1736488_2/tri*/priv/x86")"
NS="$(resolve_dir_path "NS2_CXC1736336_2/ns*/priv/x86")"
ROOTFS="$(resolve_dir_path "ROOTFS2_CXC1733870_2/rootfs*/priv/x86/i686")"
RHAI="$(resolve_dir_path "RHAI*/rhai*/priv/x86")"

if [ "${RHAI}" == "" ]; then
    PGH="$(resolve_dir_path "PGH2_CXC1734937_2/pgh2*/priv/x86")"
else
    PGH=${RHAI}
fi

TRAUTIL="$(resolve_dir_path "TRACE-UTILS2_*/tra*/priv/x86")"
TED=$(find_patch ${TRAUTIL}/sbin/ted)

ITCD=$(find_patch ${ITC}/sbin/itcworld)

LD_LIBRARY_PATH=${ITC}/lib:${LD_LIBRARY_PATH}
LD_LIBRARY_PATH=${LITS}/lib:${SDS}/lib:${COLI}/lib:${LD_LIBRARY_PATH:-}

start_log "Using itcgw"
ITCGW=$(find_patch ${ITC}/bin/itcgw)

COLID=$(find_patch ${COLI}/sbin/colid)
TRID=$(find_patch ${TRI}/sbin/trid)
NSD=$(find_patch ${NS}/sbin/ns)
PGHD=$(find_patch ${PGH}/bin/pghd)
LTTNGD=$(find_patch ${ROOTFS}/usr/bin/lttng-sessiond)
LTTNG=$(find_patch ${ROOTFS}/usr/bin/lttng)
LTTNGCONSD=$(find_patch ${ROOTFS}/usr/lib/lttng/libexec/lttng-consumerd)
LTTNGCONSDLIB=$(find_patch ${ROOTFS}/usr/lib)

[ -d "$DEFDIR" ] && {
    if [ "${RCS_MODE}" = simulated ]; then
	PIPE_DIR=${PIPE_DIR:-${RCS_ROOT}/tmp}
    fi
}

USEL_LOG_DIR=${RCS_ROOT}/usel
mkdir -p  ${USEL_LOG_DIR}  > /dev/null 2>&1
usel=

if [ "$UNIQ" = "" ];  then
    USEL_SNAME=usel_$USER
else
    USEL_SNAME=usel_${UNIQ}_$USER
fi

PIPE_DIR=${PIPE_DIR:-$DEFDIR/$USER/tmp}
mkdir ${PIPE_DIR}/${USEL_SNAME}@${HOST} > /dev/null 2>&1
USEL_PIPE_DIR=${PIPE_DIR}/${USEL_SNAME}@${HOST:?Environment variable HOST must be set}


if [ -x /opt/quest/bin/sudo ]; then
    SUDO=/opt/quest/bin/sudo
else
    SUDO=/usr/bin/sudo
fi

#start_log "LD_LIBRARY_PATH=$LD_LIBRARY_PATH"

case "$1" in
    start)
	start_log "$0 start not available any more"
	;;
    startUsel)
	startItc
	startDaemons
	;;

    stop)
	start_log "$0 stop not available any more"
	;;
    
    stopUsel)
	export LD_LIBRARY_PATH=${DEV_PATCHES}:${LD_LIBRARY_PATH}
	stopLttTri
	stopDaemons
	sleep 2
	;;


    stopall)
	start_log "Stopping RBS CS simulated EE (all daemons for one user)"
	stopEEall
	;;

    startTri)
	startLttTri
	;;

    stopTri)
	stopLttTri
	;;

    restart)
	start_log "$0 restart not available any more"
	;;

    restartUsel)
	start_log "Restarting RBS CS simulated EE"
#	getEEStatus
	stopLttTri
	stopDaemons
	start_log "Sleep a while before starting up EE"
	sleep 6
	startItc
	sleep 1
	startDaemons
#	getEEStatus
	start_log "restartUsel DONE"
	;;

    status)
	getEEStatus
	;;

     *)
	Usage
	;;
esac
