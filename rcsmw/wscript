#!/usr/bin/env python

import subprocess
import shutil, os, re
from waflib.Configure import conf
from waflib import Task
from waflib import Build


APPNAME = 'RCS'
VERSION = '1.0'
HWMB	= os.path.abspath('HWC/xml/BBhw')

COMMIT  = subprocess.check_output(['git', 'rev-parse', 'HEAD']).strip()

top = '.'
out = 'build'

def options(opt):
   opt.load('compiler_c')
   opt.add_option('--dvsn', action='store', default=VERSION, help='specify VERSION')
   opt.add_option('--vsn', action='store', default=VERSION, help='specify VERSION')
   opt.add_option('--hwmb', action='store', default=HWMB, help='specify HWMB')
   opt.add_option('--erlvsn', action='store', default=COMMIT, help='VSN attribute used when building erlang files (DEFAULT commit-id)')
   opt.add_option('--tgt', action='store', default="", help='specify target/privdir prefix (i.e. tgt_i686_32)')
   opt.add_option('--lib', action='store', default="lib", help='specify library dir name (i.e. lib, lib32, lib64)')
   opt.add_option('--prd', action='store', default="vrcs", help='product structure to use')
   opt.add_option('--pkg', action='store_true', default=False, help='create UP in cxs format + CXP/CXA packages')
   opt.add_option('--zip', action='store_true', default=False, help='create UP in zip format + CXP/CXA packages')
   opt.add_option('--img', action='store_true', default=False, help='create qcow2 image. Implies --pkg')
   opt.add_option('--sim32', action='store_true', default=False, help='create sim32 qcow2 image. Implies --pkg')

# Function for overriding writing to wafcache.
# This is used in order to only read from cache
# at build time without updating it.
def put_files_cache(self):
    pass

def configure(conf):
   conf.load('compiler_c')
   conf.load('rcstools', tooldir="tools/")

   conf.env.append_value('CFLAGS', ['-Wall', '-g', '-std=gnu99'])
   conf.env.HWMB = conf.options.hwmb
   conf.env.tgt = conf.options.tgt
   conf.env.lib = conf.options.lib
   conf.env.prd = conf.options.prd

   conf.add_os_flags('FRAMEWORK_NAME')
   conf.add_os_flags('FRAMEWORK_NO')
   conf.add_os_flags('FRAMEWORK_REV')
   conf.add_os_flags('SYSTEM_NAME')
   conf.add_os_flags('SYSTEM_NO')
   conf.add_os_flags('SYSTEM_REV')
   conf.add_os_flags('EE_REV')
   conf.add_os_flags('EE_URL')
   conf.add_os_flags('RCS_DUS2_REV')
   conf.add_os_flags('RCS_DUS2_URL')
   conf.add_os_flags('RCS_DUS3_REV')
   conf.add_os_flags('RCS_DUS3_URL')
   conf.add_os_flags('RCS_T_REV')
   conf.add_os_flags('RCS_T_URL')
   conf.add_os_flags('KATLA_REV')
   conf.add_os_flags('KATLA_URL')
   conf.add_os_flags('TAIPAN_REV')
   conf.add_os_flags('TAIPAN_URL')
   conf.add_os_flags('TIGER_REV')
   conf.add_os_flags('TIGER_URL')
   conf.add_os_flags('MTIGER_REV')
   conf.add_os_flags('MTIGER_URL')
   conf.msg("Source System Product:", ''.join(conf.env.SYSTEM_NAME)+" "+''.join(conf.env.SYSTEM_NO)+" "+''.join(conf.env.SYSTEM_REV) )
   conf.msg("Framework Product:", ''.join(conf.env.FRAMEWORK_NAME)+" "+''.join(conf.env.FRAMEWORK_NO)+" "+''.join(conf.env.FRAMEWORK_REV) )
   conf.msg("checking for EE_REV:", str(conf.env.EE_REV))
   conf.msg("checking for EE_URL:", str(conf.env.EE_URL))
   conf.msg("checking for RCS_DUS2_REV:", str(conf.env.RCS_DUS2_REV))
   conf.msg("checking for RCS_DUS2_URL:", str(conf.env.RCS_DUS2_URL))
   conf.msg("checking for RCS_DUS3_REV:", str(conf.env.RCS_DUS3_REV))
   conf.msg("checking for RCS_DUS3_URL:", str(conf.env.RCS_DUS3_URL))
   conf.msg("checking for RCS_T_REV:", str(conf.env.RCS_T_REV))
   conf.msg("checking for RCS_T_URL:", str(conf.env.RCS_T_URL))

   conf.msg("checking for HWMB:", str(conf.env.HWMB))
   conf.msg("checking for KATLA_REV:", str(conf.env.KATLA_REV))
   conf.msg("checking for KATLA_URL:", str(conf.env.KATLA_URL))
   conf.msg("checking for TAIPAN_REV:", str(conf.env.TAIPAN_REV))
   conf.msg("checking for TAIPAN_URL:", str(conf.env.TAIPAN_URL))
   conf.msg("checking for TIGER_REV:", str(conf.env.TIGER_REV))
   conf.msg("checking for TIGER_URL:", str(conf.env.TIGER_URL))
   conf.msg("checking for MTIGER_REV:", str(conf.env.MTIGER_REV))
   conf.msg("checking for MTIGER_URL:", str(conf.env.MTIGER_URL))

   conf.add_os_flags('COBRA_REV')
   conf.add_os_flags('COBRA_URL')
   conf.msg("checking for COBRA_REV:", str(conf.env.COBRA_REV))
   conf.msg("checking for COBRA_URL:", str(conf.env.COBRA_URL))

   conf.add_os_flags('RSTATEF_FLAGS')

   conf.find_program('protoc-c', var='PROTOC_C')
   conf.find_program('erl',      var='ERL')
   conf.find_program('rstatef',  var='RSTATEF')
   conf.find_program('create_sig.sh', var="CREATE_SIG")

   conf.check_cc(lib='rhai_sys', uselib_store='rhai', mandatory=False)
   conf.check_cc(lib='rhai_hwl', uselib_store='rhai', mandatory=False)
   conf.check_cc(lib='rhai_mmi', uselib_store='rhai', mandatory=False)

   conf.check_cc(lib='itc', linkflags='-Wl,--allow-shlib-undefined,-unresolved-symbols=ignore-in-shared-libs,--no-undefined',  uselib_store='crl')
   conf.check_cc(lib='eri_ng', uselib_store='crl', use='crl')
   conf.check_cc(lib='mduif',    uselib_store='mduif', use='crl', mandatory=False)


   lits_main = """
#include <ose.h>
int __wrap_main(int argc, char* argv[])
{
   return 0;
}
   """

   conf.check_cc(fragment=lits_main, lib='lits', header_name='ose.h',
         linkflags=['-Wl,--wrap,main'], uselib_store='lits', use=['crl', 'rt'])
   conf.check_cc(fragment=lits_main, lib='coli',  use=['crl', 'lits'], uselib_store='coli')
   conf.check_cc(fragment=lits_main, lib='tri',   use=['crl', 'lits'], uselib_store='tri')

   conf.check_cc(lib='ns',    uselib_store='crl', use='crl')
   conf.check_cc(lib='lttng-ust',    uselib_store='ltt')
   conf.check_cc(lib='lttng-ctl',    uselib_store='ltt', use='ltt')
   conf.check_cc(lib='lttng-ust-tracepoint', uselib_store='ltt', use='ltt')

   conf.check_cc(lib='urcu',        uselib_store='urcu')
   conf.check_cc(lib='urcu-bp',     uselib_store='urcu', use='urcu')
   conf.check_cc(lib='urcu-cds',    uselib_store='urcu', use='urcu')
   conf.check_cc(lib='urcu-common', uselib_store='urcu', use='urcu')

   conf.check_cc(lib='protobuf-c', uselib_store='proto')

   conf.check_cc(lib='pthread', uselib_store='rt')
   conf.check_cc(lib='dl'     , uselib_store='rt')
   conf.check_cc(lib='rt',      uselib_store='rt', use='rt')

   conf.check_cc(lib='netsnmp',      uselib_store='netsnmp')
   conf.check_cc(lib='netsnmpagent', uselib_store='netsnmp')
   conf.check_cc(lib='netsnmphelpers',uselib_store='netsnmp')

   conf.check_cc(lib='uuid', uselib_store='uuid')

   conf.define('APPNAME', APPNAME)
   conf.define('VERSION', VERSION)
   conf.write_config_header('config.h')

# A small helper function. Build all erlang sources and the app description
# file. The path to application directory is returned.
@conf
def rcsErlApp(bld, name, inc=[], defines=[], subdir="", enable_cxa=True, enable_cxc=True, extra_erl=[], cxaid="", cxcid="", appdataroot=""):
   lmc, cxa, cxc = bld.env.APPS[name]
   cxafull = name.upper()+"_"+cxa

   APP = bld.getAPP(name)
   if "proto" in inc:
      bld.stlib(features="c", target=name+"_proto", name=name+"_proto",
            includes="proto",
            cflags="-fPIC",
            source=bld.path.ant_glob("proto/*.proto"), app=APP)
      bld.add_group()
   if "model" in inc:
      modelfiles = bld.path.ant_glob("model/*.xml")
      bld(source=modelfiles)
      bld.install_files("${PREFIX}/"+APP+"/priv/model", modelfiles)
      bld.add_group()
   if enable_cxc and cxc:
      erl  = bld.path.ant_glob("esrc/%s/*.erl"%subdir) + extra_erl
      erl  = filter(lambda x: not str(x).endswith("_eunit.erl"), erl)
      bld(source=erl, includes=inc, defines=defines, app=APP)
      appsrc  = bld.path.ant_glob("esrc/%s/%s.appSrc"%(subdir,name))
      if '/test/' in str(appsrc):
          bld(source="esrc/%s/%s.appSrc"%(subdir,name), id=cxc, vsn=bld.env.DVSN, app=APP, modules=erl)
      else:
	  bld(source="esrc/%s/%s.appSrc"%(subdir,name), id=cxc, vsn=bld.env.VSN, app=APP, modules=erl)

   if enable_cxa and cxa:
      buildtime= '${PREFIX}/%s/'%cxafull
      bld.install_files(buildtime+'/model',       bld.path.ant_glob("model/*"))
      bld.install_files(buildtime+'/doc',         bld.path.ant_glob("doc/*"))
      bld.install_files(buildtime+'/emx',         bld.path.ant_glob("emx/*"))
      bld.install_files(buildtime+'/schema',      bld.path.ant_glob("schema/*"))
      bld.install_files(buildtime+'/include',     bld.path.ant_glob("inc/*"))
      if bld.path.ant_glob("inc/*"):
          bld.symlink_as(buildtime+'/inc',         "include")

   return APP

def isUnstripped(f):
    return (re.match(r".*\.so\.?\d*", f) or '.' not in f)\
            and 'not stripped' in subprocess.check_output(['file', f])

# Overwrite the default copy function. We would need to perserv symbolic links
# and strip the ELF files.
def copy_fun(self, src, tgt):
    if os.path.islink(src):
        linkto = os.readlink(src)
        os.symlink(linkto, tgt)
    else:
        if isUnstripped(src):
            print subprocess.check_output(self.env.STRIP +
                    ['-v', '--strip-debug', '--strip-unneeded', '-o', tgt, src])
        else:
            shutil.copy2(src, tgt)
        os.chmod(tgt, self.chmod)
Build.inst.copy_fun = copy_fun

# Get private dir or any of its subdirectories for a given APP.
@conf
def getAPP(bld, name, cxaid="", cxcid="", appdataroot=""):
   lmc, cxa, cxc = bld.env.APPS[name]
   lmcname, id, _, _, _ = bld.env.LMC[lmc]
   name = name.split("/")[-1]
   if "DUMMY" in lmcname:
       return "%s_%s/%s/%s-%s" % (lmcname, id, cxc, name, bld.env.DVSN)
   else:
       return "%s_%s/%s/%s-%s" % (lmcname, id, cxc, name, bld.env.VSN)

@conf
def getPrv(bld, APP):
   return '${PREFIX}/'+APP+'/priv/'

@conf
def getTgt(bld, APP):
   return bld.getPrv(APP)+bld.env.tgt

@conf
def getBin(bld, APP):
   return bld.getTgt(APP)+'/bin'

@conf
def getLib(bld, APP):
   return bld.getTgt(APP)+'/'+bld.env.lib

@conf
def getBldtime(bld, name):
   lmc, cxa, cxc = bld.env.APPS[name]
   return '${PREFIX}/%s_%s/'%(name.upper(), cxa)

@conf
def getBldLib(bld, name):
    return bld.getBldtime(name)+'/'+bld.env.tgt+'/'+bld.env.lib+'/'

def build(bld):
   exec(open("tools/config/%s_product.py" %bld.env.prd).read())

   bld.env.DVSN = bld.options.dvsn
   bld.env.VSN = bld.options.vsn
   bld.env.USE_GUPMAKER = USE_GUPMAKER
   bld.env.ERLVSN = bld.options.erlvsn
   bld.env.append_value('INCLUDES', [i.abspath() for i in bld.path.ant_glob('*/inc', dir=True)])
   bld.env.APPS = APPS
   bld.env.LMC = LMC
   bld.env.EXT_LMC = EXT_LMC
   bld.env.EXT2_LMC = EXT2_LMC
   bld.env.BUNDLED_LMC = BUNDLED_LMC
   bld.env.BASELINE = BASELINE
   bld.env.UP = UP
   bld.env.ZIP = bld.options.zip


   for dir in SRCDIR:
      bld.recurse(dir)

   if bld.options.zip or bld.options.pkg or bld.options.img or bld.options.sim32:
      bld.recurse('out')
