#!/usr/bin/expect -f

set argc [llength $argv]
if {$argc < 3} {
   puts "\nBrief : reboot test"
   puts "If no loop \"end count\" is given - repeat indefinitely"
   puts "The test loop is always, however, terminated if an error"
   puts "is detected."
   puts "Note! application crashes are not considered errors"
   puts "those are only counted - as long as system don't reboot"
   puts "on it's own account and rhsd boot process complete, test loop"
   puts "is not interrupted\n"
   puts "\nSyntax: $argv0 <board> <user> <start count> \[<end count>\]\n" 
   puts "- $argv0 dus3020 user-id 0"
   puts "- $argv0 dus3020 user-id 0 1000"
   puts "\nNote!"
   puts "user-id is ericsson id for person that should receive email"
   puts "when test loop state changes. If not found in LDAP the user that runs"
   puts "this script will recieve anoying spam mails about undeliverable mail"
   puts "\nNote!!"
   puts "This script assumes uboot environment setup by:"
   puts "init_uboot_env.expect"
   puts "\nNote!"
   puts "sm-err.sh  sm-start.sh  sm-stop.sh must be found in path"
   exit 1
}

set board   [lindex $argv 0]
set user    [lindex $argv 1]
set counter [lindex $argv 2]

set max_cnt 0
set crash   0

if {$argc > 3} {
   set max_cnt   [lindex $argv 3]
   puts "\nSet end counter to value $max_cnt\n"
   exec sm-start.sh $argv0 $board "Start loop on $counter stop after $max_cnt loops" $user
} else {
   puts "\nLoop until fail\n"
   exec sm-start.sh $argv0 $board "Start - Loop until fail" $user
}

trap {
     puts "\nKilled by signal\n"
     exec sm-stop.sh $argv0 $board "Trap SIGINT after $counter loops" $user
     exit 1
} SIGINT

# Establish connection
set timeout 10
spawn /proj/rcs/bin/rcs_telnet.pl $board
expect {
    timeout {puts "\nNo contact with the board, GoodBye!\n"; exit 1}
    "yes/no" {send "yes\r"; exp_continue}
    "Escape character is '^]'."
}


while {1} {

      if {$max_cnt != 0} {
      	 if {$counter >= $max_cnt} {
       	    puts "\nGreat success $counter loops completed\n"
       	    exec sm-stop.sh $argv0 $board "Great success $counter loops completed" $user
       	    exit 
         }
      }

# Are we alive?
# for nodes with old uboot and no rlog
# catch console from uboot if WD triggered restart

    set timeout 10
    send "root\r"
    sleep  1
    expect {
	timeout {
		puts "\nNot possible to login\n"
		exec sm-err.sh $argv0 $board "Not possible to login" $user
		set timeout 70
		expect {
		       timeout {
		       	       puts "\nGoodBye!\n"
		       }
		       "Starting kernel ..." {
		       		 puts "\nExtra reboot detected\n"
				 exec sm-err.sh $argv0 $board "Extra reboot detected" $user
		       }
		}
		exit 1
	}
	"*login:" { send "root\r"; exp_continue }
	"*assword:" { send "root\r"; set cmd 1 }
	"*command not found"       { set cmd 1 }
    }

    send "uname\r"
    expect "Linux"
    sleep  1

# look for unwanted restarts....
    set timeout 2
    send "llog -c\r"
    expect {
	timeout {}
	"*HW watchdog*" {
	    puts "\n\n ...WDOG!\n"
	    exec sm-err.sh $argv0 $board "WDOG detected by kernel" $user
	    exit 1
	}
        "*Program Crash*" {
            puts "\n\n ...Program Crash!\n"
            incr crash
            exec sm-err.sh $argv0 $board "Loop : $counter, Program crash : $crash" $user
        }
 
    }

    set timeout 5
    send "rhdc npulog\r"
    expect {
           "ERROR configuration timeout" {
	   	  puts "\nNPU load TMO. GoodBye!\n"
		  exec sm-err.sh $argv0 $board "NPU configuration TMO" $user
		  exit 1
	   }
           timeout {
	   	   puts "\nrhsd npulog TMO. GoodBye!\n"
		   exec sm-err.sh $argv0 $board "NPU configuration TMO" $user
		   exit 1
           }
	   "NCP_ST_SUCCESS(0)" {
	   		       puts "\nOkidoki......\n"
			       exp_continue
           }
           "(\[^\r]*)\r" {
	   		 exp_continue
           }
           "*# "
    }

    sleep 10

    send "cat /sys/rbs-fn/rbs-sys/boot_count\r"
    expect {
    	   timeout {
	   	   puts "\nread boot count TMO. GoodBye!\n"
		   exec sm-err.sh $argv0 $board "read boot count TMO" $user
		   exit 1
	   }
	   "0" {
	       puts "\nBoot counter is reset\n"
	   }
    }
# may come some later to
    set timeout 2
    send "llog -c\r"
    expect {
           timeout {}
           "*Program Crash*" {
           	      puts "\n\n ...Program Crash!\n"
            	      incr crash
            	      exec sm-err.sh $argv0 $board "Loop : $counter, Program crash : $crash" $user
          }
    }

    set timeout 70
    send "date\r"
    expect "UTC 201*"
    send "pgh_restartbrd 10\r"

# verify that uboot stage2 started correctly
    expect {
	timeout {
		puts "\n0: U-Boot stage2 not started, timeout. GoodBye!\n"
		exec sm-err.sh $argv0 $board "0: U-Boot stage2 not started, timeout" $user
		exit 1
	}
	"RCS: Reset Status = HW Watchdog" {
	      puts "\n0: watchdog restart detected in U-Boot. GoodBye!\n"
	      exec sm-err.sh $argv0 $board "0: watchdog restart detected in U-Boot" $user
	      exit 1
	}
	"System initialized"
    }


# verify that uboot stage3 started correctly
    expect {
	timeout {
		puts "\n1: U-Boot stage3 not started, timeout. GoodBye!\n"
		exec sm-err.sh $argv0 $board "1: U-Boot stage3 not started, timeout" $user
		exit 1
	}
	"RCS: Reset Status = HW Watchdog" {
	      puts "\n1: watchdog restart detected in U-Boot. GoodBye!\n"
	      exec sm-err.sh $argv0 $board "1: watchdog restart detected in U-Boot" $user
	      exit 1
	}
	"RCS: Reset Status = SW Ordered (Cold)"
    }


# verify that kernel starts
    expect {
	timeout {
		puts "\n2: Linux kernel not started, timeout. GoodBye!\n"
		exec sm-err.sh $argv0 $board "2: Linux kernel not started" $user
		exit 1
	}
	"Starting kernel ..."
    }

# verify that boot completed
    set timeout 50
    expect {
	timeout {
		puts "\n3: Linux boot not completed, timeout. GoodBye!\n"
		exec sm-err.sh $argv0 $board "3: Linux boot not completed" $user
		exit 1
        }
	"RCS: Reset Status = HW Watchdog" {
	      puts "\nExtra reboot detected GoodBye!\n"
	      exec sm-err.sh $argv0 $board "Extra reboot detected" $user
	      exit 1
	}
	"*Starting RCS program handler"
    }

    incr counter
    send_user "\n\n*****************************\n"
    send_user "===> Number of Reloads = $counter\n"
    send_user "*****************************\n\n"


    sleep 10
    
}
